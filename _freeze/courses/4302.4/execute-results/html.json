{
  "hash": "95bda63b52614959384f33e40299a3bd",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Auxiliar 4\nsubtitle: Sem谩foros\nauthor: \n    - Vicente Gonz谩lez\n    - Pablo Jaramillo\nfooter: CC4302 --- Sistemas Operativos\nfrom: markdown+emoji\nformat:\n    revealjs:\n        theme: night\n        print-separate-fragments: true\n        transition: fade\n---\n\n\n\n# Contexto\n## Sem谩foros\n\n## Manejo {.smaller}\n::: {.fragment}\n### Inicializaci贸n\n:::\n::: {.fragment}\n::: {.columns}\n::: {.column width=\"60%\"}\nUsando macros\n```{.c} \npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n```\n:::\n::: {.column width=\"40%\"}\n\nDentro de una funci贸n\n```{.c} \npthread_mutex_t mutex;\n// ...\npthread_mutex_init(&mutex, NULL);\n```\n:::\n:::\n:::\n\n::: {.fragment}\n### Uso\n:::\n::: {.fragment}\nPara solicitar el mutex:\n```{.c} \nint pthread_mutex_lock(pthread_mutex_t *mutex); \n```\n[*La funci贸n retorna solo para el primer proceso que pida el mutex, el resto queda esperando*]{style=\"font-size:80%\"}\n:::\n\n::: {.fragment}\nPara liberar el mutex:\n\n```{.c} \nint pthread_mutex_unlock(pthread_mutex_t *mutex); \n```\n[*Al liberar el mutex, [todos]{style=\"color:orange\"} los procesos se despiertan a la vez, \n[no]{style=\"color:orange\"} esta garantizado el orden de adquisici贸n*]{style=\"font-size:80%\"}\n:::\n\n\n## Comportamiento\n::: {.incremental}\n- Un mutex garantiza que s贸lo un proceso pueda entrar a una su \"zona cr铆tica\" de c贸digo.\n- Debe ser solicitado para ingresar y liberado al salir.\n- Dos estados posibles:\n\n::: {.columns .fragment}\n::: {.column width=\"50%\"}\n#### Abierto\n[ Ning煤n proceso ha solicitado el mutex ]{style=\"font-size:80%\"}\n:::\n::: {.column width=\"50%\"}\n#### Cerrado\n[ Alg煤n proceso ha solicitado el mutex y no ha sido liberado ]{style=\"font-size:80%\"}\n:::\n:::\n\n- Si un proceso intenta solicitar un mutex cerrado, este ser谩 suspendido hasta que el mutex sea liberado.\n:::\n\n## Ejemplo {.center auto-animate=true}\n```{.c} \nint contador = 0;\nvoid aumentar_cont() {\n  contador++;\n}\n```\n::: {.fragment}\nMala implementaci贸n あ\n:::\n\n::: {.r-stack}\n::: {.fragment .fade-in-then-out}\n驴D贸nde esta el error?\n:::\n\n::: {.fragment}\nHagamos un diagrama\n:::\n:::\n\n# Problemas\n\n## P1 -- Ba帽o compartido\nUn estadio posee un 煤nico ba帽o que debe ser compartido por hinchas rojos y azules. \nEl ba帽o es amplio y admite un n煤mero ilimitado de personas. \nEl problema consiste en evitar que los hinchas rojos se encuentren con los hinchas azules dentro del ba帽o.\n\nLos hinchas rojos solicitan entrar al ba帽o invocando `entrar(ROJO)` y notifican su salida con `salir(ROJO)`, \nmientras que los hinchas azules invocan `entrar(AZUL)` y `salir(AZUL)`.\n\n## P1 -- Ba帽o compartido\n### Parte A\nSe plantea la siguiente soluci贸n incorrecta para el problema:\n::: {.columns}\n::: {.column width=\"\"}\n\n\n\n```{c}\nenum { ROJO = 0, AZUL =  1};\n\nint cantidad[2] = {0, 0};\n\n// Este mutex representa el acceso al ba帽o\n// El equipo que lo tiene es el que est谩 adentro\nint mutex = 0; \n\nvoid entrar(int color) {\n    if (cantidad[color] == 0) {\n        while(mutex)\n            ;\n        mutex = 1;\n    }\n    cantidad[color]++;\n}\n\nvoid salir(int color) {\n    cantidad[color]--;\n    if (cantidad[color] == 0) {\n        mutex = 0;\n    }\n}\n```\n\n\n\n:::\n::: {.column width=\"\"}\n\n:::\n:::\n\n## P1 -- Ba帽o compartido\n### Parte B\n\n## P2 -- \n\n## Creaci贸n de un thread \n```{.c} \nint pthread_create(pthread_t *thread, \n                   const pthread_attr_t *attr, \n                   void *(*start_routine)(void *), \n                   void *arg);\n```\n::: {.incremental}\n- Lanza un nuevo `thread` que ejecuta `start_routine`.\n- `start_routine` recibe `arg` como argumento.\n- El `thread` se puede crear con atributos `attr` especiales (`NULL`).\n- El \"ID\" del proceso se guarda en `thread`\n- Retorna 0 si la creaci贸n del proceso fue exitosa\n:::\n\n## T茅rmino de un thread \n::: {.fragment}\nUn `thread` termina si:\n:::\n::: {.incremental}\n- Retorna `start_routine`.\n- Llamando a `pthread_exit` (no recomendado).\n\n    ```{.c} \n    int pthread_exit(void *return_value);\n    \n    ```\n:::\n\n::: {.fragment}\nTodo `thread` cread debe ser **enterrado** con\n\n```{.c} \nint pthread_join(pthread_t thread, void **return_value);\n```\n:::\n::: {.fragment}\n- `pthread_join` **espera** a que el `thread` termine.\n:::\n\n::: {.fragment style=\"color:red; font-size: 70%\"}\nLos thread no enterrados se convierte en zombies y no devuelven los recursos\n:::\n\n## Ejemplo {.smaller auto-animate=true}\n```{.c code-line-numbers=\"|4-8|10-19\"} \n#include <stdio.h>\n#include <pthread.h>\n\nvoid *thread(void *ptr) {\n  char* nombre = (char*) ptr; // Castear argumento\n  printf(\"Thread - %s\\n\", nombre); // Trabajo en paralelo\n  return NULL; // Retorno\n}\n\nint main() {\n  pthread_t pid_1, pid_2; // Guardar PID de los threads lanzados\n  char* nombre_1 = \"primero\";\n  char* nombre_2 = \"segundo\";\n  pthread_create(&pid_1, NULL, thread, nombre_1); // lanzar thread1\n  pthread_create(&pid_2, NULL, thread, nombre_2); // lanzar thread2\n  pthread_join(pid_1, NULL); // esperar thread 1\n  pthread_join(pid_2, NULL); // esperar thread 2\n  return 0;\n}\n\n```\n\n## Ejemplo (m煤ltiples `args`) {.smaller auto-animate=true}\n```{.c code-line-numbers=\"4-7|10-11|17-18|19-20\"} \n#include <stdio.h>\n#include <pthread.h>\n\ntypedef struct {\n  char* name;\n  int age;\n} Args;\n\nvoid *thread(void *ptr) {\n  Args* a = (Args*) ptr; // Castear a la estructura\n  printf(\"Thread - %s (%d)\\n\", a->name, a->age); // Accedemos a los miembros con ->\n  return NULL; // Retorno\n}\n\nint main() {\n  pthread_t pid_1, pid_2; // Guardar PID de los threads lanzados\n  Args a1 = {\"primero\", 10} // inicializamos los args de t1\n  Args a2 = {\"segundo\", 20} // inicializamos los args de t2\n  pthread_create(&pid_1, NULL, thread, &a1); // la pasamos por referencia\n  pthread_create(&pid_2, NULL, thread, &a2); // la pasamos por referencia\n  pthread_join(pid_1, NULL); // esperar thread 1\n  pthread_join(pid_2, NULL); // esperar thread 2\n  return 0;\n}\n```\n\n## How to? {.smaller}\n### Dise帽o\n\n::: {.incremental}\n1. Encontrar las partes paralelizables\n2. Crear la estructura que permita ingresar los argumentos necesarios\n3. Programar la rutina\n:::\n\n::: {.incremental}\n- A veces la rutina s贸lo ajusta los argumentos para llamar a otra funci贸n\n- En la estructura de los argumentos podemos guardar **cualquier** cosa\n:::\n\n::: {.aside}\n*Esto es no pretende ser una receta, sino que una gu铆a general*\n:::\n## How to? {.smaller}\n### L贸gica\n::: {.incremental}\n1. Lanzar los `threads` con sus argumentos correspondientes\n2. Si aplica, realizar trabajo en el `thread` principal\n3. Esperar a que el trabajo paralelizado termine\n4. Enterrar los resultados y recolectar los resultados\n:::\n\n::: {.incremental}\n- Antes del `join` no existe garant铆a de que el trabajo se haya terminado\n- Aseg煤rese de que exista paralelismo entre el `create` y el `join`\n:::\n\n::: {.aside}\n*Esto es no pretende ser una receta, sino que una gu铆a general*\n:::\n## P1 --- Quicksort paralelo {.smaller}\nLa siguiente funci贸n es una implementaci贸n simple de quicksort:\n```{.c} \n#include <pthread.h>\n\nvoid quicksort_seq(int a[], int i, int j) {\n    if (i < j) {\n        int h = particionar(a, i, j);\n        quicksort_seq(a, i, h - 1);\n        quicksort_seq(a. h + 1, j);\n    }\n}\n```\n::: {.r-stack}\n::: {.fragment .fade-in-then-out}\nConsidere `particionar` como la funci贸n que selecciona el pivote y\nreordena el arreglo.\n\nLos valores menores al pivote quedan a la izquierda y los mayores a la derecha.\n\nSe le pide paralelizar la funci贸n tal que haga uso de $N$ cores:\n\n```{.c} \nvoid quicksort(int a[], int i, int j, int n);\n```\n:::\n::: {.fragment}\n### Idea\nInvocaciones secuenciales independientes son directamente paralelizables\n:::\n:::\n\n# Sincronizaci贸n\n*Lo nuevo*\n\n## La nueva pesadilla\n::: {.fragment}\nCuando se trabaja en paralelo, nacen nuevos [enemigos]{style=\"color:red\"}.\n:::\n::: {.fragment}\nAl acceder a recursos compartidos desde varios procesos se pueden generar problemas como:\n:::\n\n::: {.incremental}\n- **Dataraces**\n\n    Variables se sobreescriben\n\n- **Race conditions**\n\n    Orden incorrecto de ejecuci贸n\n\n- **Hambruna y Deadlocks**\n\n    Un proceso no obtiene tiempo de ejecuci贸n\n:::\n\n##\n![](./res/Superman.jpeg){fig-align=\"center\"}\n\n## La soluci贸n\n::: {.fragment}\n### Mutex\n:::\n::: {.r-stack}\n::: {.fragment .fade-in-then-out}\nMUTual EXclusi贸n\n:::\n::: {.fragment}\nGarantiza la exclusi贸n mutua, bloqueando el acceso a \"zonas cr铆ticas\",\nlas cuales son zonas del c贸digo donde se manipulan los recursos compartidos.\n:::\n:::\n::: {.fragment}\n### Condiciones\n:::\n::: {.fragment}\nHacen esperar a los procesos de manera eficiente hasta que se cumpla la condici贸n\npara continuar la ejecuci贸n.\n:::\n# Mutex\n\n## Manejo {.smaller}\n::: {.fragment}\n### Inicializaci贸n\n:::\n::: {.fragment}\n::: {.columns}\n::: {.column width=\"60%\"}\nUsando macros\n```{.c} \npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n```\n:::\n::: {.column width=\"40%\"}\n\nDentro de una funci贸n\n```{.c} \npthread_mutex_t mutex;\n// ...\npthread_mutex_init(&mutex, NULL);\n```\n:::\n:::\n:::\n\n::: {.fragment}\n### Uso\n:::\n::: {.fragment}\nPara solicitar el mutex:\n```{.c} \nint pthread_mutex_lock(pthread_mutex_t *mutex); \n```\n[*La funci贸n retorna solo para el primer proceso que pida el mutex, el resto queda esperando*]{style=\"font-size:80%\"}\n:::\n\n::: {.fragment}\nPara liberar el mutex:\n\n```{.c} \nint pthread_mutex_unlock(pthread_mutex_t *mutex); \n```\n[*Al liberar el mutex, [todos]{style=\"color:orange\"} los procesos se despiertan a la vez, \n[no]{style=\"color:orange\"} esta garantizado el orden de adquisici贸n*]{style=\"font-size:80%\"}\n:::\n\n\n## Comportamiento\n::: {.incremental}\n- Un mutex garantiza que s贸lo un proceso pueda entrar a una su \"zona cr铆tica\" de c贸digo.\n- Debe ser solicitado para ingresar y liberado al salir.\n- Dos estados posibles:\n\n::: {.columns .fragment}\n::: {.column width=\"50%\"}\n#### Abierto\n[ Ning煤n proceso ha solicitado el mutex ]{style=\"font-size:80%\"}\n:::\n::: {.column width=\"50%\"}\n#### Cerrado\n[ Alg煤n proceso ha solicitado el mutex y no ha sido liberado ]{style=\"font-size:80%\"}\n:::\n:::\n\n- Si un proceso intenta solicitar un mutex cerrado, este ser谩 suspendido hasta que el mutex sea liberado.\n:::\n\n## Ejemplo {.center auto-animate=true}\n```{.c} \nint contador = 0;\nvoid aumentar_cont() {\n  contador++;\n}\n```\n::: {.fragment}\nMala implementaci贸n あ\n:::\n\n::: {.r-stack}\n::: {.fragment .fade-in-then-out}\n驴D贸nde esta el error?\n:::\n\n::: {.fragment}\nHagamos un diagrama\n:::\n:::\n\n\n## Ejemplo {.center auto-animate=true}\n```{.c} \npthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;\nint contador = 0;\nvoid aumentar_cont() {\n  pthread_mutex_lock(&m);\n  contador++;\n  pthread_mutex_unlock(&m);\n}\n```\n::: {.fragment}\nBuena implementaci贸n \n:::\n::: {.r-stack}\n::: {.fragment}\nRepitamos el diagrama\n:::\n:::\n\n\n# Condiciones\n## Motivaci贸n\n::: {.fragment}\nUna forma de esperar podr铆a ser:\n```{.c} \nwhile (ocupado) {\n    ; // wait\n}\n```\n:::\n\n::: {.fragment}\nEsto es [mala idea]{style=\"color:red\"} porque mantiene ocupado al *core*\n:::\n\n::: {.fragment}\nEs mejor \"dormir\" el proceso para desocupar el *core*\n:::\n\n## Manejo {.smaller}\n::: {.fragment}\n### Inicializaci贸n\n:::\n::: {.fragment}\n::: {.columns}\n::: {.column width=\"60%\"}\nUsando macros\n```{.c} \npthread_cond_t mutex = PTHREAD_COND_INITIALIZER;\n```\n:::\n::: {.column width=\"40%\"}\n\nDentro de una funci贸n\n```{.c} \npthread_cond_t cond;\n// ...\npthread_cond_init(&cond, NULL);\n```\n:::\n:::\n:::\n\n::: {.fragment}\n### Uso\n:::\n::: {.fragment}\nPara hacer esperar a un proceso:\n```{.c} \nint pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex); \n```\n[*Al entrar en espera, el proceso liberar谩 el mutex*]{style=\"font-size:80%\"}\n\n[*Al salir de espera, el proceso esperar谩 el mutex y la funci贸n retornar谩 cuando lo obtenga*]{style=\"font-size:80%\"}\n:::\n::: {.fragment}\nPara despertar procesos:\n\n```{.c} \nint pthread_cond_broadcast(pthread_cond_t *cond); // despertar a todos\nint pthread_cond_signal(pthread_cond_t *cond); // despertar uno (cualquiera)\n```\n:::\n\n## Comportamiento\n::: {.incremental}\n- La espera es [eficiente]{style=\"color:orange\"}, dejando disponible el *core*.\n- La funci贸n `wait` se hace cargo de liberar y pedir el mutex asociado.\n- La funci贸n `broadcast` despierta a todos los procesos en espera.\n- La funci贸n `signal` despierta a un solo proceso sin orden garantizado.\n- Un proceso que esperaba por una condici贸n puede quedar en espera por un mutex.\n:::\n\n## Ejemplo {auto-animate=true}\n\n```{.c} \npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    while(contador < 10) {;}\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg贸 a 10\");\n    return 0;\n}\n```\n::: {.fragment}\nMala implementaci贸n あ\n:::\n\n\n## Ejemplo {auto-animate=true}\n\n```{.c code-line-numbers=\"6\"} \npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    while(contador < 10) {;}\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg贸 a 10\");\n    return 0;\n}\n```\nBusy waiting\n\n## Ejemplo {auto-animate=true}\n\n```{.c code-line-numbers=\"4,7\"} \npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    while(contador < 10) {;}\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg贸 a 10\");\n    return 0;\n}\n```\nHambruna\n\n::: {.incremental}\n- Toma el mutex y no lo libera antes de esperar\n- No es Deadlock porque el primer proceso est谩 despierto\n:::\n## Ejemplo {auto-animate=true}\n```{.c } \npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    if(contador == 10){\n        pthread_cond_broadcast(&cond);\n    }\n    while(contador < 10){\n        pthread_cond_wait(&cond, &mutex);\n    }\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg贸 a 10\");\n    return 0; \n}\n```\n\n## Ejemplo {auto-animate=true}\n\n```{.c code-line-numbers=\"2,8\"} \npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    if(contador == 10){\n        pthread_cond_broadcast(&cond);\n    }\n    while(contador < 10){\n        pthread_cond_wait(&cond, &mutex);\n    }\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg贸 a 10\");\n    return 0; \n}\n```\nCondiciones a帽adidas\n\n## Ejemplo {auto-animate=true}\n\n```{.c code-line-numbers=\"10-12\"} \npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    if(contador == 10){\n        pthread_cond_broadcast(&cond);\n    }\n    while(contador < 10){\n        pthread_cond_wait(&cond, &mutex);\n    }\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg贸 a 10\");\n    return 0; \n}\n```\nEspera eficiente\n\n## Ejemplo {auto-animate=true}\n\n```{.c code-line-numbers=\"5,13\"} \npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    if(contador == 10){\n        pthread_cond_broadcast(&cond);\n    }\n    while(contador < 10){\n        pthread_cond_wait(&cond, &mutex);\n    }\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg贸 a 10\");\n    return 0; \n}\n```\nZona cr铆tica respetada\n\n## Ejemplo {auto-animate=true}\n\n```{.c } \npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    if(contador == 10){\n        pthread_cond_broadcast(&cond);\n    }\n    while(contador < 10){\n        pthread_cond_wait(&cond, &mutex);\n    }\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg贸 a 10\");\n    return 0; \n}\n```\nBuena implementaci贸n \n\n## P2 --- Colecta {.smaller}\n\nSe necesita crear un sistemas para juntar exactamente una cantidad $X$ de dinero:\n\n::: {.incremental}\na. Definir el tipo de datos `Colecta`.\nb. Programar la funci贸n \n\n    ```{.c} \n    Colecta *nuevaColecta(double meta);\n    ```\n\n    Que crea y retorna una colecta para juntar `meta` pesos.\nc. Programar la funci贸n \n    \n    ```{.c} \n    double aportar(Colecta *c, double monto);\n    ```\n\n    Que es invocada desde m煤ltiples procesos para contribuir `monto` pesos.\n    El valor de retorno de la funci贸n es el m铆nimo entre `monto` y lo que falta\n    para llegar a la meta. \n\n    **La funci贸n retornar una vez que la meta se cumpla**\n:::\n\n# Fin\n*[Ver otras auxiliares](4302.0.qmd)*\n\n",
    "supporting": [
      "4302.4_files"
    ],
    "filters": [],
    "includes": {}
  }
}