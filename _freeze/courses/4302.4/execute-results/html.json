{
  "hash": "95bda63b52614959384f33e40299a3bd",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Auxiliar 4\nsubtitle: Semáforos\nauthor: \n    - Vicente González\n    - Pablo Jaramillo\nfooter: CC4302 --- Sistemas Operativos\nfrom: markdown+emoji\nformat:\n    revealjs:\n        theme: night\n        print-separate-fragments: true\n        transition: fade\n---\n\n\n\n# Contexto\n## Semáforos\n\n## Manejo {.smaller}\n::: {.fragment}\n### Inicialización\n:::\n::: {.fragment}\n::: {.columns}\n::: {.column width=\"60%\"}\nUsando macros\n```{.c} \npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n```\n:::\n::: {.column width=\"40%\"}\n\nDentro de una función\n```{.c} \npthread_mutex_t mutex;\n// ...\npthread_mutex_init(&mutex, NULL);\n```\n:::\n:::\n:::\n\n::: {.fragment}\n### Uso\n:::\n::: {.fragment}\nPara solicitar el mutex:\n```{.c} \nint pthread_mutex_lock(pthread_mutex_t *mutex); \n```\n[*La función retorna solo para el primer proceso que pida el mutex, el resto queda esperando*]{style=\"font-size:80%\"}\n:::\n\n::: {.fragment}\nPara liberar el mutex:\n\n```{.c} \nint pthread_mutex_unlock(pthread_mutex_t *mutex); \n```\n[*Al liberar el mutex, [todos]{style=\"color:orange\"} los procesos se despiertan a la vez, \n[no]{style=\"color:orange\"} esta garantizado el orden de adquisición*]{style=\"font-size:80%\"}\n:::\n\n\n## Comportamiento\n::: {.incremental}\n- Un mutex garantiza que sólo un proceso pueda entrar a una su \"zona crítica\" de código.\n- Debe ser solicitado para ingresar y liberado al salir.\n- Dos estados posibles:\n\n::: {.columns .fragment}\n::: {.column width=\"50%\"}\n#### Abierto\n[ Ningún proceso ha solicitado el mutex ]{style=\"font-size:80%\"}\n:::\n::: {.column width=\"50%\"}\n#### Cerrado\n[ Algún proceso ha solicitado el mutex y no ha sido liberado ]{style=\"font-size:80%\"}\n:::\n:::\n\n- Si un proceso intenta solicitar un mutex cerrado, este será suspendido hasta que el mutex sea liberado.\n:::\n\n## Ejemplo {.center auto-animate=true}\n```{.c} \nint contador = 0;\nvoid aumentar_cont() {\n  contador++;\n}\n```\n::: {.fragment}\nMala implementación 🤢\n:::\n\n::: {.r-stack}\n::: {.fragment .fade-in-then-out}\n¿Dónde esta el error?\n:::\n\n::: {.fragment}\nHagamos un diagrama\n:::\n:::\n\n# Problemas\n\n## P1 -- Baño compartido\nUn estadio posee un único baño que debe ser compartido por hinchas rojos y azules. \nEl baño es amplio y admite un número ilimitado de personas. \nEl problema consiste en evitar que los hinchas rojos se encuentren con los hinchas azules dentro del baño.\n\nLos hinchas rojos solicitan entrar al baño invocando `entrar(ROJO)` y notifican su salida con `salir(ROJO)`, \nmientras que los hinchas azules invocan `entrar(AZUL)` y `salir(AZUL)`.\n\n## P1 -- Baño compartido\n### Parte A\nSe plantea la siguiente solución incorrecta para el problema:\n::: {.columns}\n::: {.column width=\"\"}\n\n\n\n```{c}\nenum { ROJO = 0, AZUL =  1};\n\nint cantidad[2] = {0, 0};\n\n// Este mutex representa el acceso al baño\n// El equipo que lo tiene es el que está adentro\nint mutex = 0; \n\nvoid entrar(int color) {\n    if (cantidad[color] == 0) {\n        while(mutex)\n            ;\n        mutex = 1;\n    }\n    cantidad[color]++;\n}\n\nvoid salir(int color) {\n    cantidad[color]--;\n    if (cantidad[color] == 0) {\n        mutex = 0;\n    }\n}\n```\n\n\n\n:::\n::: {.column width=\"\"}\n\n:::\n:::\n\n## P1 -- Baño compartido\n### Parte B\n\n## P2 -- \n\n## Creación de un thread \n```{.c} \nint pthread_create(pthread_t *thread, \n                   const pthread_attr_t *attr, \n                   void *(*start_routine)(void *), \n                   void *arg);\n```\n::: {.incremental}\n- Lanza un nuevo `thread` que ejecuta `start_routine`.\n- `start_routine` recibe `arg` como argumento.\n- El `thread` se puede crear con atributos `attr` especiales (`NULL`).\n- El \"ID\" del proceso se guarda en `thread`\n- Retorna 0 si la creación del proceso fue exitosa\n:::\n\n## Término de un thread \n::: {.fragment}\nUn `thread` termina si:\n:::\n::: {.incremental}\n- Retorna `start_routine`.\n- Llamando a `pthread_exit` (no recomendado).\n\n    ```{.c} \n    int pthread_exit(void *return_value);\n    \n    ```\n:::\n\n::: {.fragment}\nTodo `thread` cread debe ser **enterrado** con\n\n```{.c} \nint pthread_join(pthread_t thread, void **return_value);\n```\n:::\n::: {.fragment}\n- `pthread_join` **espera** a que el `thread` termine.\n:::\n\n::: {.fragment style=\"color:red; font-size: 70%\"}\nLos thread no enterrados se convierte en zombies y no devuelven los recursos\n:::\n\n## Ejemplo {.smaller auto-animate=true}\n```{.c code-line-numbers=\"|4-8|10-19\"} \n#include <stdio.h>\n#include <pthread.h>\n\nvoid *thread(void *ptr) {\n  char* nombre = (char*) ptr; // Castear argumento\n  printf(\"Thread - %s\\n\", nombre); // Trabajo en paralelo\n  return NULL; // Retorno\n}\n\nint main() {\n  pthread_t pid_1, pid_2; // Guardar PID de los threads lanzados\n  char* nombre_1 = \"primero\";\n  char* nombre_2 = \"segundo\";\n  pthread_create(&pid_1, NULL, thread, nombre_1); // lanzar thread1\n  pthread_create(&pid_2, NULL, thread, nombre_2); // lanzar thread2\n  pthread_join(pid_1, NULL); // esperar thread 1\n  pthread_join(pid_2, NULL); // esperar thread 2\n  return 0;\n}\n\n```\n\n## Ejemplo (múltiples `args`) {.smaller auto-animate=true}\n```{.c code-line-numbers=\"4-7|10-11|17-18|19-20\"} \n#include <stdio.h>\n#include <pthread.h>\n\ntypedef struct {\n  char* name;\n  int age;\n} Args;\n\nvoid *thread(void *ptr) {\n  Args* a = (Args*) ptr; // Castear a la estructura\n  printf(\"Thread - %s (%d)\\n\", a->name, a->age); // Accedemos a los miembros con ->\n  return NULL; // Retorno\n}\n\nint main() {\n  pthread_t pid_1, pid_2; // Guardar PID de los threads lanzados\n  Args a1 = {\"primero\", 10} // inicializamos los args de t1\n  Args a2 = {\"segundo\", 20} // inicializamos los args de t2\n  pthread_create(&pid_1, NULL, thread, &a1); // la pasamos por referencia\n  pthread_create(&pid_2, NULL, thread, &a2); // la pasamos por referencia\n  pthread_join(pid_1, NULL); // esperar thread 1\n  pthread_join(pid_2, NULL); // esperar thread 2\n  return 0;\n}\n```\n\n## How to? {.smaller}\n### Diseño\n\n::: {.incremental}\n1. Encontrar las partes paralelizables\n2. Crear la estructura que permita ingresar los argumentos necesarios\n3. Programar la rutina\n:::\n\n::: {.incremental}\n- A veces la rutina sólo ajusta los argumentos para llamar a otra función\n- En la estructura de los argumentos podemos guardar **cualquier** cosa\n:::\n\n::: {.aside}\n*Esto es no pretende ser una receta, sino que una guía general*\n:::\n## How to? {.smaller}\n### Lógica\n::: {.incremental}\n1. Lanzar los `threads` con sus argumentos correspondientes\n2. Si aplica, realizar trabajo en el `thread` principal\n3. Esperar a que el trabajo paralelizado termine\n4. Enterrar los resultados y recolectar los resultados\n:::\n\n::: {.incremental}\n- Antes del `join` no existe garantía de que el trabajo se haya terminado\n- Asegúrese de que exista paralelismo entre el `create` y el `join`\n:::\n\n::: {.aside}\n*Esto es no pretende ser una receta, sino que una guía general*\n:::\n## P1 --- Quicksort paralelo {.smaller}\nLa siguiente función es una implementación simple de quicksort:\n```{.c} \n#include <pthread.h>\n\nvoid quicksort_seq(int a[], int i, int j) {\n    if (i < j) {\n        int h = particionar(a, i, j);\n        quicksort_seq(a, i, h - 1);\n        quicksort_seq(a. h + 1, j);\n    }\n}\n```\n::: {.r-stack}\n::: {.fragment .fade-in-then-out}\nConsidere `particionar` como la función que selecciona el pivote y\nreordena el arreglo.\n\nLos valores menores al pivote quedan a la izquierda y los mayores a la derecha.\n\nSe le pide paralelizar la función tal que haga uso de $N$ cores:\n\n```{.c} \nvoid quicksort(int a[], int i, int j, int n);\n```\n:::\n::: {.fragment}\n### Idea\nInvocaciones secuenciales independientes son directamente paralelizables\n:::\n:::\n\n# Sincronización\n*Lo nuevo*\n\n## La nueva pesadilla\n::: {.fragment}\nCuando se trabaja en paralelo, nacen nuevos [enemigos]{style=\"color:red\"}.\n:::\n::: {.fragment}\nAl acceder a recursos compartidos desde varios procesos se pueden generar problemas como:\n:::\n\n::: {.incremental}\n- **Dataraces**\n\n    Variables se sobreescriben\n\n- **Race conditions**\n\n    Orden incorrecto de ejecución\n\n- **Hambruna y Deadlocks**\n\n    Un proceso no obtiene tiempo de ejecución\n:::\n\n##\n![](./res/Superman.jpeg){fig-align=\"center\"}\n\n## La solución\n::: {.fragment}\n### Mutex\n:::\n::: {.r-stack}\n::: {.fragment .fade-in-then-out}\nMUTual EXclusión\n:::\n::: {.fragment}\nGarantiza la exclusión mutua, bloqueando el acceso a \"zonas críticas\",\nlas cuales son zonas del código donde se manipulan los recursos compartidos.\n:::\n:::\n::: {.fragment}\n### Condiciones\n:::\n::: {.fragment}\nHacen esperar a los procesos de manera eficiente hasta que se cumpla la condición\npara continuar la ejecución.\n:::\n# Mutex\n\n## Manejo {.smaller}\n::: {.fragment}\n### Inicialización\n:::\n::: {.fragment}\n::: {.columns}\n::: {.column width=\"60%\"}\nUsando macros\n```{.c} \npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n```\n:::\n::: {.column width=\"40%\"}\n\nDentro de una función\n```{.c} \npthread_mutex_t mutex;\n// ...\npthread_mutex_init(&mutex, NULL);\n```\n:::\n:::\n:::\n\n::: {.fragment}\n### Uso\n:::\n::: {.fragment}\nPara solicitar el mutex:\n```{.c} \nint pthread_mutex_lock(pthread_mutex_t *mutex); \n```\n[*La función retorna solo para el primer proceso que pida el mutex, el resto queda esperando*]{style=\"font-size:80%\"}\n:::\n\n::: {.fragment}\nPara liberar el mutex:\n\n```{.c} \nint pthread_mutex_unlock(pthread_mutex_t *mutex); \n```\n[*Al liberar el mutex, [todos]{style=\"color:orange\"} los procesos se despiertan a la vez, \n[no]{style=\"color:orange\"} esta garantizado el orden de adquisición*]{style=\"font-size:80%\"}\n:::\n\n\n## Comportamiento\n::: {.incremental}\n- Un mutex garantiza que sólo un proceso pueda entrar a una su \"zona crítica\" de código.\n- Debe ser solicitado para ingresar y liberado al salir.\n- Dos estados posibles:\n\n::: {.columns .fragment}\n::: {.column width=\"50%\"}\n#### Abierto\n[ Ningún proceso ha solicitado el mutex ]{style=\"font-size:80%\"}\n:::\n::: {.column width=\"50%\"}\n#### Cerrado\n[ Algún proceso ha solicitado el mutex y no ha sido liberado ]{style=\"font-size:80%\"}\n:::\n:::\n\n- Si un proceso intenta solicitar un mutex cerrado, este será suspendido hasta que el mutex sea liberado.\n:::\n\n## Ejemplo {.center auto-animate=true}\n```{.c} \nint contador = 0;\nvoid aumentar_cont() {\n  contador++;\n}\n```\n::: {.fragment}\nMala implementación 🤢\n:::\n\n::: {.r-stack}\n::: {.fragment .fade-in-then-out}\n¿Dónde esta el error?\n:::\n\n::: {.fragment}\nHagamos un diagrama\n:::\n:::\n\n\n## Ejemplo {.center auto-animate=true}\n```{.c} \npthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;\nint contador = 0;\nvoid aumentar_cont() {\n  pthread_mutex_lock(&m);\n  contador++;\n  pthread_mutex_unlock(&m);\n}\n```\n::: {.fragment}\nBuena implementación 🤠\n:::\n::: {.r-stack}\n::: {.fragment}\nRepitamos el diagrama\n:::\n:::\n\n\n# Condiciones\n## Motivación\n::: {.fragment}\nUna forma de esperar podría ser:\n```{.c} \nwhile (ocupado) {\n    ; // wait\n}\n```\n:::\n\n::: {.fragment}\nEsto es [mala idea]{style=\"color:red\"} porque mantiene ocupado al *core*\n:::\n\n::: {.fragment}\nEs mejor \"dormir\" el proceso para desocupar el *core*\n:::\n\n## Manejo {.smaller}\n::: {.fragment}\n### Inicialización\n:::\n::: {.fragment}\n::: {.columns}\n::: {.column width=\"60%\"}\nUsando macros\n```{.c} \npthread_cond_t mutex = PTHREAD_COND_INITIALIZER;\n```\n:::\n::: {.column width=\"40%\"}\n\nDentro de una función\n```{.c} \npthread_cond_t cond;\n// ...\npthread_cond_init(&cond, NULL);\n```\n:::\n:::\n:::\n\n::: {.fragment}\n### Uso\n:::\n::: {.fragment}\nPara hacer esperar a un proceso:\n```{.c} \nint pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex); \n```\n[*Al entrar en espera, el proceso liberará el mutex*]{style=\"font-size:80%\"}\n\n[*Al salir de espera, el proceso esperará el mutex y la función retornará cuando lo obtenga*]{style=\"font-size:80%\"}\n:::\n::: {.fragment}\nPara despertar procesos:\n\n```{.c} \nint pthread_cond_broadcast(pthread_cond_t *cond); // despertar a todos\nint pthread_cond_signal(pthread_cond_t *cond); // despertar uno (cualquiera)\n```\n:::\n\n## Comportamiento\n::: {.incremental}\n- La espera es [eficiente]{style=\"color:orange\"}, dejando disponible el *core*.\n- La función `wait` se hace cargo de liberar y pedir el mutex asociado.\n- La función `broadcast` despierta a todos los procesos en espera.\n- La función `signal` despierta a un solo proceso sin orden garantizado.\n- Un proceso que esperaba por una condición puede quedar en espera por un mutex.\n:::\n\n## Ejemplo {auto-animate=true}\n\n```{.c} \npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    while(contador < 10) {;}\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador llegó a 10\");\n    return 0;\n}\n```\n::: {.fragment}\nMala implementación 🤢\n:::\n\n\n## Ejemplo {auto-animate=true}\n\n```{.c code-line-numbers=\"6\"} \npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    while(contador < 10) {;}\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador llegó a 10\");\n    return 0;\n}\n```\nBusy waiting\n\n## Ejemplo {auto-animate=true}\n\n```{.c code-line-numbers=\"4,7\"} \npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    while(contador < 10) {;}\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador llegó a 10\");\n    return 0;\n}\n```\nHambruna\n\n::: {.incremental}\n- Toma el mutex y no lo libera antes de esperar\n- No es Deadlock porque el primer proceso está despierto\n:::\n## Ejemplo {auto-animate=true}\n```{.c } \npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    if(contador == 10){\n        pthread_cond_broadcast(&cond);\n    }\n    while(contador < 10){\n        pthread_cond_wait(&cond, &mutex);\n    }\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador llegó a 10\");\n    return 0; \n}\n```\n\n## Ejemplo {auto-animate=true}\n\n```{.c code-line-numbers=\"2,8\"} \npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    if(contador == 10){\n        pthread_cond_broadcast(&cond);\n    }\n    while(contador < 10){\n        pthread_cond_wait(&cond, &mutex);\n    }\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador llegó a 10\");\n    return 0; \n}\n```\nCondiciones añadidas\n\n## Ejemplo {auto-animate=true}\n\n```{.c code-line-numbers=\"10-12\"} \npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    if(contador == 10){\n        pthread_cond_broadcast(&cond);\n    }\n    while(contador < 10){\n        pthread_cond_wait(&cond, &mutex);\n    }\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador llegó a 10\");\n    return 0; \n}\n```\nEspera eficiente\n\n## Ejemplo {auto-animate=true}\n\n```{.c code-line-numbers=\"5,13\"} \npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    if(contador == 10){\n        pthread_cond_broadcast(&cond);\n    }\n    while(contador < 10){\n        pthread_cond_wait(&cond, &mutex);\n    }\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador llegó a 10\");\n    return 0; \n}\n```\nZona crítica respetada\n\n## Ejemplo {auto-animate=true}\n\n```{.c } \npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    if(contador == 10){\n        pthread_cond_broadcast(&cond);\n    }\n    while(contador < 10){\n        pthread_cond_wait(&cond, &mutex);\n    }\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador llegó a 10\");\n    return 0; \n}\n```\nBuena implementación 🤠\n\n## P2 --- Colecta {.smaller}\n\nSe necesita crear un sistemas para juntar exactamente una cantidad $X$ de dinero:\n\n::: {.incremental}\na. Definir el tipo de datos `Colecta`.\nb. Programar la función \n\n    ```{.c} \n    Colecta *nuevaColecta(double meta);\n    ```\n\n    Que crea y retorna una colecta para juntar `meta` pesos.\nc. Programar la función \n    \n    ```{.c} \n    double aportar(Colecta *c, double monto);\n    ```\n\n    Que es invocada desde múltiples procesos para contribuir `monto` pesos.\n    El valor de retorno de la función es el mínimo entre `monto` y lo que falta\n    para llegar a la meta. \n\n    **La función retornar una vez que la meta se cumpla**\n:::\n\n# Fin\n*[Ver otras auxiliares](4302.0.qmd)*\n\n",
    "supporting": [
      "4302.4_files"
    ],
    "filters": [],
    "includes": {}
  }
}