{
  "hash": "a1b0025a17a8be7fa10ba7ae8cc7afbd",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Auxiliar 7\nsubtitle: Timeouts y Prioridades\nauthor: \n    - Vicente González\n    - Pablo Jaramillo\nfooter: CC4302 --- Sistemas Operativos\nfrom: markdown+emoji\nformat:\n    revealjs:\n        theme: night\n        pdf-separate-fragments: true\n        transition: slide\n        chalkboard: true\n---\n\n# Contexto\n## Mensajes\n\n::: {.columns}\n::: {.column width=\"50%\"}\n\n\n![`nSend(th, *msg);`](./res/cc4302.insane.1.png){height=\"500\"}\n\n:::\n::: {.column width=\"50%\"}\n\n![`nReceive(*pth, timeout_ms);`](./res/cc4302.insane.2.png){height=\"500\"}\n:::\n:::\n\n## *How to?*\n\n## Timeouts\n\n\n# Problemas\n## Impresora compartida {.smaller auto-animate=true}\n\n::: {.columns}\n::: {.column width=\"50%\"}\nPatron Request\n\n\n```{c} \nvoid obtenerImpresora(){\n  pthread_mutex_lock(&m);\n  Request req = {FALSE, \n                 PTHREAD_COND_INITIALIZER};\n  put(q, &req);\n  pthread_cond_signal(&obtener);\n  while (!req.ready){\n    pthread_cond_wait(&req.w, &m);\n  }\n  pthread_mutex_unlock(&m);\n}\n\nvoid devolverImpresora(){\n  pthread_mutex_lock(&m);\n  ocupada = FALSE;\n  pthread_cond_signal(&devolver);\n  pthread_mutex_unlock(&m);\n}\n```\n\n\n:::\n::: {.column width=\"50%\"}\n✨Mensajes✨ \n\n```{.c} \nenum Mensaje {OBTENER, DEVOLVER};\n\nvoid obtenerImpresora(){\n  int msg = OBTENER;\n  // Bloquear thread hasta recibir respuesta\n  nSend(impresora, &msg);\n}\nvoid devolverImpresora(){\n  int msg = DEVOLVER;\n  nSend(impresora, &msg);\n}\n```\n:::\n:::\n\n## Impresora compartida {.smaller auto-animate=true}\nPatron Request\n\n```{.c style=\"font-size:70%\"} \nvoid ImpresoraServer() {\n  while(TRUE) {\n    pthread_mutex_lock(&m);\n    if(emptyQueue(q)) {\n      struct timespec ts;\n      clock_gettime(CLOCK_REALTIME, &ts);\n      ts.tv_sec += 60*5;\n      while(emptyQueue(q) && pthread_cond_timed_wait(&obtener, &m, &ts) != ETIMEDOUT) {\n        ;//wait por 5 mins\n      }\n\n      if(emptyQueue(q)) {\n        modoBajoConsumo();\n        while (emptyQueue(q)) {\n          pthread_cond_wait(&obtener, &m);\n        }\n        modoUsoNormal();\n      }\n    }\n\n    if(!emptyQueue(q)) {\n      Request *req = get(q);\n      req -> ready = TRUE;\n      ocupada = TRUE;\n      pthread_cond_signal(&req->w);\n    }\n\n    while(ocupada){\n      pthread_cond_wait(&devolver, &m);\n    }\n    pthread_mutex_unlock(&m);\n  }\n}\n```\n\n## Impresora compartida {.smaller auto-animate=true}\n✨Mensajes✨ \n\n```{.c style=\"font-size:60%\"} \nint ImpresoraServer() {\n  Queue *q = makeQueue();\n  int ocupado = FALSE;\n  nThread t;\n  int *msg;\n  while (TRUE) {\n    // Si no esta ocupada, esperar\n    if (!ocupado) {\n      // esperar 5 minutos (5min * 60s * 1000ms)\n      msg = (int *) nReceive(&t, 60 * 5 * 1000);\n      if (t == NULL) {\n        modoBajoConsumo();\n        msg = (int*) nRecieve(&t,\n        -1); // esperar\n        modoUsoNormal();\n      }\n    } else { // Esperar a que se desocupe impresora\n      msg = (int*) nReceive(&t, -1); // esperar\n      if (*msg == OBTENER) {\n        // Encolar si esta ocupada,\n        if (ocupado)\n          put(q,t);\n        else { // responder si esta disponible\n          ocupado = TRUE;\n          nReply(t,0);\n        }\n      } else if (*msg == DEVOLVER) {\n        nReply(t, 0); // “ok, la devolviste”\n        if (EmptyFifoQueue(q)) {\n          ocupado = FALSE;\n        } else {\n          // Entregar impresora a siguiente thread\n          nThread *t2 = (nThread*) get(q);\n          nReply(t2, 0);\n        }\n      }\n    }\n  }\n}\n\n```\n\n## *So far so good* {.center}\n\n## P1 -- Timeouts\nImplemente:\n\n```{.c} \nint nSend(nThread th, void *msg)\n\nvoid *nReceive(nThread *pth, int timeout_ms)\n\nvoid nReply(nThread th, int rc)\n```\nEsta vez con timeouts!!\n\n## P2 -- Scheduler de prioridades {.smaller auto-animate=true}\nVeamos como se implementan las prioridades\n\n```{.c} \n#include \"nthread-impl.h\"\n\nstatic NthQueue *nth_pri1ReadyQueue[MAXPRI];\n\nvoid nSetPriority(nThread th, int pri) {\n  START_CRITICAL\n  \n  th->pri= pri;\n  schedule(); // The calling thread may loose the CPU if its priority is lower\n  \n  END_CRITICAL\n}\n```\n\n## P2 -- Scheduler de prioridades {.smaller auto-animate=true}\nVeamos como se implementan las prioridades\n\n```{.c} \nstatic void nth_pri1SetReady(nThread th) {\n  CHECK_CRITICAL(\"nth_fcfsSetReady\")\n  \n  if (th->status==READY || th->status==RUN)\n    nFatalError(\"nth_fcfsReady\", \"The thread was already in READY status\\n\");\n\n  th->status= READY;\n  nth_putBack(nth_pri1ReadyQueue[th->pri], th);\n}\n```\n\n## P2 -- Scheduler de prioridades {.smaller auto-animate=true}\nVeamos como se implementan las prioridades\n\n```{.c} \nstatic void nth_pri1Suspend(State waitState) {\n  CHECK_CRITICAL(\"nth_fcfsSuspend\")\n  \n  nThread th= nSelf();\n  if (th->status!=RUN && th->status!=READY)\n    nFatalError(\"nth_fcfsSuspend\", \"Thread was not ready or run\\n\");\n  th->status= waitState;\n}\n```\n\n## P2 -- Scheduler de prioridades {.smaller auto-animate=true}\nVeamos como se implementan las prioridades\n\n```{.c style=\"font-size:60%\"} \nstatic void nth_pri1Schedule(void) {\n  CHECK_CRITICAL(\"nth_fcfsSchedule\")\n  \n  nThread thisTh= nSelf();\n  if (thisTh!=NULL && (thisTh->status==READY || thisTh->status==RUN)) {\n    thisTh->status= READY;\n    nth_putBack(nth_pri1ReadyQueue[thisTh->pri], thisTh);\n  }\n  nThread nextTh= NULL;\n  while (nextTh==NULL) {\n    int i=0;\n    while (i<MAXPRI) {\n      if (!nth_emptyQueue(nth_pri1ReadyQueue[i]))\n        break;\n      i++;\n    }\n    if (i<MAXPRI) {\n      nextTh= nth_getFront(nth_pri1ReadyQueue[i]);\n      break;\n    }\n    else {\n      nth_coreIsIdle[0]= 1; // To prevent a signal handler to call\n                                       // recursively this scheduler\n      sigsuspend(&nth_sigsetApp);\n      nth_coreIsIdle[0]= 0;\n    }\n  }\n\n  // The context change: give this core to nextTh\n  // it will take a while to return from here\n  // Meanwhile thread nextTh and others are being executed\n  \n  nth_changeContext(thisTh, nextTh);\n  \n  // Some time later, at return the scheduler gave back onother core\n  // to thisTh, but most probably coreId() != prevCoreId\n\n  nth_setSelf(thisTh); // Set current running thread: from now on, nSelf()\n                       // gives thisTh\n  \n  thisTh->status= RUN;\n}\n```\n\n## P2 -- Scheduler de prioridades {.smaller auto-animate=true}\nVeamos como se implementan las prioridades\n\n```{.c} \nstatic void nth_pri1Stop(void) {\n  CHECK_CRITICAL(\"nth_fcfsStop\")\n  \n  for (int i= 0; i<MAXPRI; i++)\n    nth_destroyQueue(nth_pri1ReadyQueue[i]);\n}\n```\n\n## P2 -- Scheduler de prioridades {.smaller auto-animate=true}\nVeamos como se implementan las prioridades\n\n```{.c style=\"font-size:70%\"} \nScheduler nth_pri1Scheduler= { .schedule = nth_pri1Schedule,\n                               .setReady = nth_pri1SetReady,\n                               .suspend = nth_pri1Suspend,\n                               .stop = nth_pri1Stop };\nvoid setPri1Scheduling() {\n  START_CRITICAL\n\n  if (nth_verbose)\n    printf(\"Info: setting single-core priority scheduling\\n\");\n  \n  if (nth_totalCores!=1)\n    nFatalError(\"setPri1Scheduling\",\n                \"This priority scheduler only accepts a single core\\n\");\n  for (int i= 0; i<MAXPRI; i++)\n    nth_pri1ReadyQueue[i]= nth_makeQueue();\n  nth_setScheduler(nth_pri1Scheduler);\n  MapIterator *iter= getMapIterator(nth_threadSet);\n  void *ptr;\n  while (mapNext(iter, &ptr, &ptr)) {\n    nThread th= ptr;\n    if (th->status==READY)\n      nth_putBack(nth_pri1ReadyQueue[th->pri], th);\n  }\n  destroyMapIterator(iter);\n  \n  END_CRITICAL\n}\n\nint isPri1Scheduling(void) {\n  return nth_scheduler.schedule==nth_pri1Scheduler.schedule;\n}\n```\n\n# Fin\n*[Ver otras auxiliares](4302.0.qmd)*\n\n",
    "supporting": [
      "4302.7_files"
    ],
    "filters": [],
    "includes": {}
  }
}