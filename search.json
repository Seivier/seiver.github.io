[
  {
    "objectID": "courses/3501.0.html",
    "href": "courses/3501.0.html",
    "title": "Modelaci√≥n y Computaci√≥n Gr√°fica para Ingeniero",
    "section": "",
    "text": "Instalaci√≥n de Herramientas\nIntroducci√≥n a OpenGL\nC√°mara e Input",
    "crumbs": [
      "Cursos",
      "2024",
      "Modelaci√≥n y Computaci√≥n Gr√°fica para Ingeniero"
    ]
  },
  {
    "objectID": "courses/3501.0.html#auxiliares",
    "href": "courses/3501.0.html#auxiliares",
    "title": "Modelaci√≥n y Computaci√≥n Gr√°fica para Ingeniero",
    "section": "",
    "text": "Instalaci√≥n de Herramientas\nIntroducci√≥n a OpenGL\nC√°mara e Input",
    "crumbs": [
      "Cursos",
      "2024",
      "Modelaci√≥n y Computaci√≥n Gr√°fica para Ingeniero"
    ]
  },
  {
    "objectID": "courses/3501.2.html#la-escena",
    "href": "courses/3501.2.html#la-escena",
    "title": "Auxiliar 2",
    "section": "La escena",
    "text": "La escena\n\n\nObjetos\n\nSon los actores de la escena\nManejar geometr√≠a, transformaciones, texturas, material y f√≠sica\n\nC√°mara\n\nSon los ojos por los que se ve la escena\nManejar posici√≥n y perspectiva\n\nLuces\n\nSon lo que le da color a la escena\nManejar posici√≥n, tipo de fuente, intensidad, sombras"
  },
  {
    "objectID": "courses/3501.2.html#la-escena-1",
    "href": "courses/3501.2.html#la-escena-1",
    "title": "Auxiliar 2",
    "section": "La escena",
    "text": "La escena"
  },
  {
    "objectID": "courses/3501.2.html#pipeline",
    "href": "courses/3501.2.html#pipeline",
    "title": "Auxiliar 2",
    "section": "Pipeline",
    "text": "Pipeline\n\n\n\n\nUna serie de pasos para obtener la imagen\nProceso complejo que involucra muchos c√°lculos\nSe puede alterar en ciertas etapas\n\nVertex Shader\nTesellation\nGeometry Shader\nFragment Shader"
  },
  {
    "objectID": "courses/3501.2.html#pipeline-1",
    "href": "courses/3501.2.html#pipeline-1",
    "title": "Auxiliar 2",
    "section": "Pipeline",
    "text": "Pipeline\n\n\n\nUna serie de pasos para obtener la imagen\nProceso complejo que involucra muchos c√°lculos\nSe puede alterar en ciertas etapas\n\nVertex Shader\nTesellation\nGeometry Shader\nFragment Shader"
  },
  {
    "objectID": "courses/3501.2.html#pipeline-2",
    "href": "courses/3501.2.html#pipeline-2",
    "title": "Auxiliar 2",
    "section": "Pipeline",
    "text": "Pipeline\nSe resume a lo siguiente:\n\n\nVertex shading: Colorear cada v√©rtice\nProjection: Proyectar los v√©rtices en la escena\nClipping: Ajustar la geometr√≠a seg√∫n lo que se ve en realidad\nScreen Mapping: Pasar de coordenadas uniformes a las coordenadas de la pantalla\nRasterization: Discretizar la imagen\nPixel processing: Colorear / procesar cada p√≠xel"
  },
  {
    "objectID": "courses/3501.2.html#shaders",
    "href": "courses/3501.2.html#shaders",
    "title": "Auxiliar 2",
    "section": "Shaders",
    "text": "Shaders\nVertex Shader\n\n\nSe encarga de definir los v√©rtices desde la memoria\nAct√∫a simult√°neamente en cada v√©rtice\nRecibe como input los datos a utilizar\nDebe definir la posici√≥n del v√©rtice\nPuede pasarle informaci√≥n a los siguientes pasos"
  },
  {
    "objectID": "courses/3501.2.html#shaders-1",
    "href": "courses/3501.2.html#shaders-1",
    "title": "Auxiliar 2",
    "section": "Shaders",
    "text": "Shaders\nFragment Shader\n\n\nSe encarga de definir el color de los p√≠xeles\nAct√∫a simult√°neamente en cada p√≠xel\nDebe definir el color final del p√≠xel\nPuede recibir informaci√≥n a desde los pasos anteriores"
  },
  {
    "objectID": "courses/3501.2.html#p1-generar-un-c√≠rculo",
    "href": "courses/3501.2.html#p1-generar-un-c√≠rculo",
    "title": "Auxiliar 2",
    "section": "P1 ‚Äî Generar un c√≠rculo",
    "text": "P1 ‚Äî Generar un c√≠rculo\nCree la siguiente funci√≥n:\ndef create_circle(x, y, radius) \nLa cual toma:\n\nLa posici√≥n del centro del c√≠rculo\nEl radio del c√≠rculo\n\nY retorna un arreglo con las posiciones de cada v√©rtice para formar el c√≠rculo"
  },
  {
    "objectID": "courses/3501.2.html#p2-a√±adir-color",
    "href": "courses/3501.2.html#p2-a√±adir-color",
    "title": "Auxiliar 2",
    "section": "P2 ‚Äî A√±adir color",
    "text": "P2 ‚Äî A√±adir color\nAhora que tiene su c√≠rculo cambie la funci√≥n anterior para incluir color:\ndef create_circle(x, y, r, g, b, radius) \nDonde \\((r, g, b)\\) son las componentes de color del c√≠rculo y tienen un valor de 0 a 1.\nAhora la funci√≥n debe incluir el color de cada v√©rtice para formar el c√≠rculo\n\n\nPropuesto: Trate de variar un poco el color para cada punto o incluso usar 2 colores"
  },
  {
    "objectID": "courses/3501.2.html#p3-agregar-indices",
    "href": "courses/3501.2.html#p3-agregar-indices",
    "title": "Auxiliar 2",
    "section": "P3 ‚Äî Agregar indices",
    "text": "P3 ‚Äî Agregar indices\nSu funci√≥n actual hace uso de mucha memoria de manera innecesaria, us√© la funci√≥n de Pyglet shader.vertex_list_indexed la cual recibe adicionalmente una lista de √≠ndices los cuales indican que v√©rtices forman un tri√°ngulo.\nPara crear esa lista programe la funci√≥n:\ndef create_circle_indices()"
  },
  {
    "objectID": "courses/3501.2.html#p4-un-poquito-de-movimiento",
    "href": "courses/3501.2.html#p4-un-poquito-de-movimiento",
    "title": "Auxiliar 2",
    "section": "P4 ‚Äî Un poquito de movimiento",
    "text": "P4 ‚Äî Un poquito de movimiento\nAhora que tiene todo listo y bonito, pruebe a√±adir las siguientes animaciones:\n\nUna en la cual el c√≠rculo crece y luego se empeque√±ece\nUna en la cual el se mueve de izquierda a derecha\nUna en la cual hay 2 c√≠rculos bailando (use su imaginaci√≥n)"
  },
  {
    "objectID": "courses/4302.4.html#sem√°foros",
    "href": "courses/4302.4.html#sem√°foros",
    "title": "Auxiliar 4",
    "section": "Sem√°foros",
    "text": "Sem√°foros\n\n\nOtra herramienta de sincronizaci√≥n\nM√°s simple que mutex con condiciones\nIgual de potente\nFunciona como un sistema de tickets o fichas\nLos procesos puede solicitar fichas o depositarlas\n\n\n\nSi no hay fichas, los procesos que soliciten deben esperar a que se deposite"
  },
  {
    "objectID": "courses/4302.4.html#manejo",
    "href": "courses/4302.4.html#manejo",
    "title": "Auxiliar 4",
    "section": "Manejo",
    "text": "Manejo\nInicializaci√≥n\n\nPara crear\nvoid sem_init(sem_t *sem, int pshared, unsigned int val);\n\n\nsem: Puntero al sem√°foro a inicializar.\npshared: Flag para indicar si el sem√°foro ser√° compartido entre threads (0) o entre procesos (1).\nval: Cantidad de fichas iniciales\n\n\n\n\nPara destruir\nvoid sem_destroy(sem_t *sem);\n\n\nsem: Puntero al sem√°foro a destruir."
  },
  {
    "objectID": "courses/4302.4.html#manejo-1",
    "href": "courses/4302.4.html#manejo-1",
    "title": "Auxiliar 4",
    "section": "Manejo",
    "text": "Manejo\nUso\n\nPara depositar una ficha:\nvoid sem_wait(sem_t *sem); \n\n\nPara extraer una ficha:\nvoid sem_post(sem_t *sem); \nAl igual que con los mutex, no esta garantizado el orden de adquisici√≥n"
  },
  {
    "objectID": "courses/4302.4.html#comportamiento",
    "href": "courses/4302.4.html#comportamiento",
    "title": "Auxiliar 4",
    "section": "Comportamiento",
    "text": "Comportamiento\n\nLos sem√°foros se pueden usar como mutex o condiciones.\n\n\n\n\nMutex\nCon una √∫nica ficha\nsem_t sem;\nsem_init(&sem, 0, 1);\nPara entrar a la zona cr√≠tica un thread solicita la ficha y al salir lo deposita\n\n\nCondiciones\nSin fichas\nsem_t sem;\nsem_init(&sem, 0, 0);\nAl llamar sem_wait el proceso debe esperar a un sem_post"
  },
  {
    "objectID": "courses/4302.4.html#ejemplo",
    "href": "courses/4302.4.html#ejemplo",
    "title": "Auxiliar 4",
    "section": "Ejemplo",
    "text": "Ejemplo\n...\nsem_wait(&sem); \nif (se_debe_esperar) {\n    sem_post(&sem); \n    sem_wait(&wait); \n    sem_wait(&sem); \n}\nsem_post(&sem); \n...\n\n\nsem act√∫a como mutex\nwait act√∫a como condici√≥n"
  },
  {
    "objectID": "courses/4302.4.html#ejemplo-1",
    "href": "courses/4302.4.html#ejemplo-1",
    "title": "Auxiliar 4",
    "section": "Ejemplo",
    "text": "Ejemplo\n...\nsem_wait(&sem); \nif (se_debe_esperar) {\n    sem_post(&sem); \n    sem_wait(&wait); \n    sem_wait(&sem); \n}\nsem_post(&sem); \n...\nPedir el mutex al entrar y salir de la zona cr√≠tica"
  },
  {
    "objectID": "courses/4302.4.html#ejemplo-2",
    "href": "courses/4302.4.html#ejemplo-2",
    "title": "Auxiliar 4",
    "section": "Ejemplo",
    "text": "Ejemplo\n...\nsem_wait(&sem); \nif (se_debe_esperar) {\n    sem_post(&sem); \n    sem_wait(&wait); \n    sem_wait(&sem); \n}\nsem_post(&sem); \n...\nEsperar a que la condici√≥n se cumpla (sin while)"
  },
  {
    "objectID": "courses/4302.4.html#ejemplo-3",
    "href": "courses/4302.4.html#ejemplo-3",
    "title": "Auxiliar 4",
    "section": "Ejemplo",
    "text": "Ejemplo\n...\nsem_wait(&sem); \nif (se_debe_esperar) {\n    sem_post(&sem); \n    sem_wait(&wait); \n    sem_wait(&sem); \n}\nsem_post(&sem); \n...\nOJO\nHay que liberar el mutex antes de esperar y pedirlo despu√©s"
  },
  {
    "objectID": "courses/4302.4.html#p1-ba√±o-compartido",
    "href": "courses/4302.4.html#p1-ba√±o-compartido",
    "title": "Auxiliar 4",
    "section": "P1 ‚Äì Ba√±o compartido",
    "text": "P1 ‚Äì Ba√±o compartido\n\nUn estadio posee un √∫nico ba√±o que debe ser compartido por hinchas rojos y azules. El ba√±o es amplio y admite un n√∫mero ilimitado de personas. El problema consiste en evitar que los hinchas rojos se encuentren con los hinchas azules dentro del ba√±o.\n\n\nLos hinchas rojos solicitan entrar al ba√±o invocando entrar(ROJO) y notifican su salida con salir(ROJO), mientras que los hinchas azules invocan entrar(AZUL) y salir(AZUL)."
  },
  {
    "objectID": "courses/4302.4.html#p1-ba√±o-compartido-1",
    "href": "courses/4302.4.html#p1-ba√±o-compartido-1",
    "title": "Auxiliar 4",
    "section": "P1 ‚Äì Ba√±o compartido",
    "text": "P1 ‚Äì Ba√±o compartido\nParte A\nSe plantea la siguiente soluci√≥n incorrecta para el problema:\n\n\nenum { ROJO = 0, AZUL =  1};\n\nint cantidad[2] = {0, 0};\n\n// Este mutex representa \n// el acceso al ba√±o, el\n// equipo que lo tiene \n// es el que est√° adentro\nint mutex = 0; \n\nvoid entrar(int color) {\n  if (cantidad[color] == 0) {\n    while(mutex)\n      ;\n    mutex = 1;\n  }\n  cantidad[color]++;\n}\n\nvoid salir(int color) {\n  cantidad[color]--;\n  if (cantidad[color] == 0) {\n    mutex = 0;\n  }\n}\n\nMuestre mediante un diagrama de threads que un hincha rojo puede entrar al ba√±o cuando hay hinchas azules presentes"
  },
  {
    "objectID": "courses/4302.4.html#p1-ba√±o-compartido-2",
    "href": "courses/4302.4.html#p1-ba√±o-compartido-2",
    "title": "Auxiliar 4",
    "section": "P1 ‚Äì Ba√±o compartido",
    "text": "P1 ‚Äì Ba√±o compartido\nParte B\nEscriba una soluci√≥n correcta y eficiente para este problema utilizando 3 sem√°foros. No importa si en su soluci√≥n algunos procesos sufren ‚Äúhambruna‚Äù\n\n\nCorrecta\n\nNo hay datarraces\n\nEficiente\n\nNo hay busy waiting\n\n\n\n\n\nHint: Utilice la estructura de la soluci√≥n incorrecta"
  },
  {
    "objectID": "courses/4302.4.html#p2-ba√±o-sin-hambruna",
    "href": "courses/4302.4.html#p2-ba√±o-sin-hambruna",
    "title": "Auxiliar 4",
    "section": "P2 ‚Äì Ba√±o sin hambruna",
    "text": "P2 ‚Äì Ba√±o sin hambruna\n\nConsidere ahora una soluci√≥n en la que no se produzca hambruna. Para lograr esto es necesario que ning√∫n hincha entre al ba√±o mientras haya hinchas del otro equipo esperando. Luego, cuando sale el √∫ltimo hincha del ba√±o, entran todos los hinchas del equipo contrario que estaban esperando. Por ejemplo, si hay dos hinchas del equipo rojo en el ba√±o y un hincha azul en espera, el siguiente hincha rojo en llegar no podr√° entrar hasta que haya entrado (y salido) el azul.\n\n\n\nParte A\nSe incluye una implementaci√≥n incorrecta de esta soluci√≥n. Demuestra que esta soluci√≥n es incorrecta confeccionando un diagrama de threads donde la exclusi√≥n mutua no se cumple.\n\n\n\nEsta parte fue adaptada de la tarea 1 del semestre 2021-1"
  },
  {
    "objectID": "courses/4302.4.html#p2-ba√±o-sin-hambruna-1",
    "href": "courses/4302.4.html#p2-ba√±o-sin-hambruna-1",
    "title": "Auxiliar 4",
    "section": "P2 ‚Äì Ba√±o sin hambruna",
    "text": "P2 ‚Äì Ba√±o sin hambruna\nParte A\n\n\n// Un sem√°foro controla el acceso\n// a la zona cr√≠tica.\nsem_t mutex; \n// Un sem√°foro para la \n// espera cada tipo de hincha. \nsem_t sem[2]; \nint esperan[2] = {0, 0}; \nint adentro[2] = {0, 0};\n\nvoid entrar(int color){\n  // el oponente del equipo AZUL \n  // es el equipo ROJO y viceversa.\n  int oponente = !color ;\n  sem_wait(&mutex);\n    // Si hay hinchas del otro equipo \n    // en el ba√±o o en la cola \n    // se debe esperar.\n    if (adentro[oponente] &gt; 0 ||\n        esperan[oponente] &gt; 0){ \n      esperan[color]++;\n      sem_post(&mutex);\n      // se pone el thread en espera \n      sem_wait(&sem[color]); \n      sem_wait(&mutex);\n    }\n    adentro[color]++; // entramos al ba√±o\n    sem_post(&mutex); \n}\n\nvoid salir(int color) {\n  int oponente = !color; \n  sem_wait(&mutex);\n  adentro[color]--; // salimos del ba√±o\n\n  if (adentro[color] == 0) {\n    // Despertar a los oponentes poniendo \n    // tantos tickets como son \n    // threads hay en espera\n    for (int i = 0; i &lt; esperan[oponente]; i++) {\n      sem_post(&sem[oponente ]); \n    }\n    esperan[oponente] = 0;\n  }\n  sem_wait(&mutex );\n}"
  },
  {
    "objectID": "courses/4302.4.html#p2-ba√±o-sin-hambruna-2",
    "href": "courses/4302.4.html#p2-ba√±o-sin-hambruna-2",
    "title": "Auxiliar 4",
    "section": "P2 ‚Äì Ba√±o sin hambruna",
    "text": "P2 ‚Äì Ba√±o sin hambruna\nParte A\n\n\nLa mayor√≠a de estos dataraces ocurren en el momento de despertar los threads en espera, en ese instante un thread extra se puede escabullir en la zona cr√≠tica (si se cumplen las condiciones para que entre y se roba el mutex). Este thread puede cambiar las variables compartidas y alterar la correctitud del programa.\nDebemos garantizar la correctitud del programa sin importar que un thread extra se robe el mutex, o debemos garantizar que nunca un thread extra pueda escabullirse.\nEn general esto se soluciona cambiando todas las variables compartidas en el thread que despierta a los dem√°s, los thread en espera se despiertan y solo deben retornar."
  },
  {
    "objectID": "courses/4302.4.html#p2-ba√±o-sin-hambruna-3",
    "href": "courses/4302.4.html#p2-ba√±o-sin-hambruna-3",
    "title": "Auxiliar 4",
    "section": "P2 ‚Äì Ba√±o sin hambruna",
    "text": "P2 ‚Äì Ba√±o sin hambruna\nParte B\nReprograme la soluci√≥n anterior de modo que siempre funcione correctamente. Utilice la siguiente metodolog√≠a:\n\nUtilice 2 colas FIFO globales, una para cada equipo.\nCuando un hincha deba esperar para entrar al ba√±o, cree un sem√°foro con 0 tickets y p√≥ngalo en la cola correspondiente. Luego, suspenda el thread solicitando un ticket a este sem√°foro.\nCuando salga el ultimo hincha de un equipo y haya hinchas del otro en espera, extraiga todos los sem√°foros de esa cola y deposite en cada uno de ellos un ticket para permitirle a los hinchas en espera entrar al ba√±o.\nUtilice un sem√°foro para garantizar exclusi√≥n mutua en el acceso a las variables globales."
  },
  {
    "objectID": "courses/3501.1.html#su-auxiliar",
    "href": "courses/3501.1.html#su-auxiliar",
    "title": "Auxiliar 1",
    "section": "Su auxiliar",
    "text": "Su auxiliar\n\n\n\n\nVicente Gonz√°lez\nAuxiliar de\n\nPSS\nComputaci√≥n en GPU\nSistemas Operativos\nMetodolog√≠as de Dise√±o y Programaci√≥n\n\nSiempre disponible en persona üòÉ\nLento para responder correos üòü\nDoble titulaci√≥n\nNo duden en preguntar"
  },
  {
    "objectID": "courses/3501.1.html#terminal",
    "href": "courses/3501.1.html#terminal",
    "title": "Auxiliar 1",
    "section": "Terminal",
    "text": "Terminal\nAlgunas cosas para manejarse mejor\n\n\n\n\n\n\n\nComando\nDescripci√≥n\n\n\n\n\ncd &lt;ruta&gt;\n¬†Cambia al directorio &lt;ruta&gt;\n\n\nls/dir\n¬†Lista los archivos y directorios en el directorio actual\n\n\nmdkir &lt;nombre&gt;\n¬†Crea un directorio nuevo llamado &lt;nombre&gt;\n\n\nmv &lt;desde&gt; &lt;hacia&gt;\n¬†Mueve un archivo/directorio &lt;desde&gt; a una ruta &lt;hacia&gt;\n\n\nrm &lt;nombre&gt;1\n¬†Elimina/borra el archivo &lt;nombre&gt;\n\n\n\n\n\nPueden abusar del Tab para que les autocomplete y agregar --help para que les explique\nPueden agregar la flag -rf para borrar carpetas enteras"
  },
  {
    "objectID": "courses/3501.1.html#python",
    "href": "courses/3501.1.html#python",
    "title": "Auxiliar 1",
    "section": "Python",
    "text": "Python"
  },
  {
    "objectID": "courses/3501.1.html#pip",
    "href": "courses/3501.1.html#pip",
    "title": "Auxiliar 1",
    "section": "PIP",
    "text": "PIP\n\n\nGestor de paquetes de Python\nViene instalado con su versi√≥n de Python\nPaquetes como venv permiten gestionar ambientes\n\n\n\n\nDetalles de la instalaci√≥n aqui"
  },
  {
    "objectID": "courses/3501.1.html#pip-1",
    "href": "courses/3501.1.html#pip-1",
    "title": "Auxiliar 1",
    "section": "PIP",
    "text": "PIP\n\n\nPara crear ambientes (se crea en la carpeta .venv)\npython -m venv venv\nPara activarlo\nsource ./venv/bin/activate\nInstalar paquetes\npip install &lt;paquete&gt;\npip install -r &lt;archivo&gt;\n\n\n\n\nDetalles de la instalaci√≥n aqui"
  },
  {
    "objectID": "courses/3501.1.html#conda",
    "href": "courses/3501.1.html#conda",
    "title": "Auxiliar 1",
    "section": "Conda",
    "text": "Conda\n\n\nAlternativa a PIP\nGestor de paquetes del sistemas\nIncorpora ambientes\nRecomiendo Miniconda\n\n\n\n\nDudas con la instalaci√≥n por correo"
  },
  {
    "objectID": "courses/3501.1.html#conda-1",
    "href": "courses/3501.1.html#conda-1",
    "title": "Auxiliar 1",
    "section": "Conda",
    "text": "Conda\n\n\nPara crear ambientes\nconda env create -n &lt;nombre&gt; \nPara activarlo\nconda activate &lt;nombre&gt;\nInstalar paquetes\nconda install &lt;paquete&gt;\n\n\n\n\nDudas con la instalaci√≥n por correo"
  },
  {
    "objectID": "courses/3501.1.html#editor",
    "href": "courses/3501.1.html#editor",
    "title": "Auxiliar 1",
    "section": "Editor",
    "text": "Editor"
  },
  {
    "objectID": "courses/3501.1.html#vscode",
    "href": "courses/3501.1.html#vscode",
    "title": "Auxiliar 1",
    "section": "VSCode",
    "text": "VSCode\n\n\nSencillo y liviano\nUsa extensiones\nMicrosoft ü§¢\nGratis ü§ë\n\n\n\nDescargar"
  },
  {
    "objectID": "courses/3501.1.html#pycharm",
    "href": "courses/3501.1.html#pycharm",
    "title": "Auxiliar 1",
    "section": "PyCharm",
    "text": "PyCharm\n\n\nCompleto\nUsa plugins\nJetBrains ü§¢\nGratis (Community) y de Pago1 (Professional)\n\n\n\nDescargar\n\nSe puede obtener gratis con una licencia educacional"
  },
  {
    "objectID": "courses/3501.1.html#vim",
    "href": "courses/3501.1.html#vim",
    "title": "Auxiliar 1",
    "section": "Vim",
    "text": "Vim\n\n\nUltra liviano pero ultra extensible\nOpen Source\nLo usa el admin (yo üòé)\nMuy dif√≠cil, no recomendado\n\n\n\nDescargar"
  },
  {
    "objectID": "courses/3501.1.html#git",
    "href": "courses/3501.1.html#git",
    "title": "Auxiliar 1",
    "section": "Git",
    "text": "Git\n\n\n\n\nPara clonar repositorios\ngit clone &lt;url&gt; &lt;nombre_carpeta&gt;\nNO es necesario para el curso\nTutorial\n\n\n\n\n\n\n\n\n\n\n\nDetalles de la instalaci√≥n aqui"
  },
  {
    "objectID": "courses/3501.1.html#hello-world",
    "href": "courses/3501.1.html#hello-world",
    "title": "Auxiliar 1",
    "section": "Hello world!",
    "text": "Hello world!\n\n\n\n\n\n\n¬øCambiemos el color?"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Inicio",
    "section": "",
    "text": "Bienvenido üòÉ"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "courses/3501.4.html#espacios-3d",
    "href": "courses/3501.4.html#espacios-3d",
    "title": "Auxiliar 4",
    "section": "Espacios 3D",
    "text": "Espacios 3D\n\nPara trabajar en tres dimensiones tenemos que tener en cuenta los espacios de nuestros objetos:\n\n\n\nLocal space\nSe corresponden con las coordenadas originales o locales del objeto, se suelen dejar homog√©neas para despu√©s manipularlas con facilidad.\nWorld space\nCorresponde al mundo donde se ubica los objetos, cada objeto tiene una posici√≥n, orientaci√≥n y tama√±o en este.\nView space\nEs el mundo que se esta viendo, por lo tanto, es solo una porci√≥n del mundo y esta vinculado a la c√°mara de la escena\nClip space\nEs espacio h√≥mogeneo de OpenGL, desde -1 a 1 en todas las coordenadas, lo que queda fuera se elimina o recorta"
  },
  {
    "objectID": "courses/3501.4.html#espacios-3d-1",
    "href": "courses/3501.4.html#espacios-3d-1",
    "title": "Auxiliar 4",
    "section": "Espacios 3D",
    "text": "Espacios 3D\n\n\n\n\n\n\n\nFuente: LearnOpenGL"
  },
  {
    "objectID": "courses/3501.4.html#espacios-3d-2",
    "href": "courses/3501.4.html#espacios-3d-2",
    "title": "Auxiliar 4",
    "section": "Espacios 3D",
    "text": "Espacios 3D\nMatriz MVP\n\n\\[\nM_{projection} \\cdot M_{view} \\cdot M_{model} \\cdot v_{local} = v_{clipped}\n\\]\n\n\nSirve para moverse desde el espacio local al espacio homog√©neo de OpenGL"
  },
  {
    "objectID": "courses/3501.4.html#modelo",
    "href": "courses/3501.4.html#modelo",
    "title": "Auxiliar 4",
    "section": "Modelo",
    "text": "Modelo\n\nPara pasar de coordenadas locales a las de mundo usamos la matriz de modelo.\n\n\n\\[\nM_{model}  = M_{translation} \\cdot M_{rotation} \\cdot M_{scale}\n\\]\n\n\nEs la que usamos la clase pasada para mover los modelos!"
  },
  {
    "objectID": "courses/3501.4.html#vista",
    "href": "courses/3501.4.html#vista",
    "title": "Auxiliar 4",
    "section": "Vista",
    "text": "Vista\n\nPara pasar de coordenadas de mundo a las de vista o de c√°mara, usamos la matriz de vista. Con un poco de magia de √°lgebra lineal tenemos que:\n\n\n\\[\nM_{view} = M_{lookat} =\n\\begin{pmatrix}\nr_x & r_y & r_z & 0\\\\\nu_x & u_y & u_z & 0\\\\\nd_x & d_y & d_z & 0\\\\\n0 & 0 & 0 & 1\\\\\n\\end{pmatrix}\n\\cdot\n\\begin{pmatrix}\n1 & 0 & 0 & -p_x\\\\\n0 & 1 & 0 & -p_y\\\\\n0 & 0 & 1 & -p_z\\\\\n0 & 0 & 0 & 1\\\\\n\\end{pmatrix}\n\\]\n\n\nDonde\n\n\\(R\\) es el vector que apunta a la derecha de la c√°mara\n\\(U\\) es el vector que apunta hacia arriba de la c√°mara\n\\(D\\) es el vector a donde apunta a la c√°mara\n\\(P\\) es la posici√≥n de la c√°mara"
  },
  {
    "objectID": "courses/3501.4.html#proyecci√≥n",
    "href": "courses/3501.4.html#proyecci√≥n",
    "title": "Auxiliar 4",
    "section": "Proyecci√≥n",
    "text": "Proyecci√≥n\n\nFinalmente, para pasar de las coordenadas de vista a las homog√©neas de OpenGL se usa la matriz de proyecci√≥n, que viene en dos sabores:\n\n\n\n\nOrtogr√°fica\n\n\n\n\n\ndef ortho(left, right, bottom, top, near, far)\n\n\nPerspectiva\n\n\n\n\n\ndef perspective(fovy, aspect, near, far):\n\n\n\nFuente: LearnOpenGL"
  },
  {
    "objectID": "courses/3501.4.html#manejo-de-input",
    "href": "courses/3501.4.html#manejo-de-input",
    "title": "Auxiliar 4",
    "section": "Manejo de input",
    "text": "Manejo de input\n\nPara manejar input podemos utilizar Pyglet la cual nos provee funciones que son llamadas durante el ciclo del juego, similar a on_draw:\n\n\n\non_key_press(symbol, modifiers): funci√≥n que se llama cuando se presiona una tecla y se guarda el valor de la tecla en symbol.\non_key_release(symbol, modifiers): funci√≥n que se llama cuando se libera una tecla y se guarda el valor de la tecla en symbol.\non_mouse_motion(x, y, dx, dy): funci√≥n que se llama cuando el mouse se mueve y guarda la posici√≥n del mouse en la ventana (x e y), as√≠ como el cambio de este (dx y dy).\n\n\n\nExisten m√°s que pueden ver en la documentaci√≥n de la librer√≠a"
  },
  {
    "objectID": "courses/3501.4.html#p1-hacerlo-con-clase",
    "href": "courses/3501.4.html#p1-hacerlo-con-clase",
    "title": "Auxiliar 4",
    "section": "P1 ‚Äî Hacerlo con clase",
    "text": "P1 ‚Äî Hacerlo con clase\n\nEl auxiliar pasado vieron realizar un mont√≥n de transformaciones para alterar los modelos, ahora veremos como abstraer el concepto de modelo en una clase.\n\n\nUna clase es una forma que se tiene para empaquetar c√≥digo, la idea es que cada clase represente algo.\n\n\nCree la clase GameModel, que contenga lo siguiente:\n\nInformaci√≥n de posici√≥n, rotaci√≥n y escalado\nColor del objeto y buffer de la GPU\nUna funci√≥n que sea capaz de entregar la matriz de modelo del objeto correspondiente\nUna funci√≥n que sea capaz de dibujar el objeto en pantalla"
  },
  {
    "objectID": "courses/3501.4.html#p1-hacerlo-con-clase-1",
    "href": "courses/3501.4.html#p1-hacerlo-con-clase-1",
    "title": "Auxiliar 4",
    "section": "P1 ‚Äî Hacerlo con clase",
    "text": "P1 ‚Äî Hacerlo con clase\nUse esta clase junto a sus nuevos conocimientos para recrear la siguiente escena:"
  },
  {
    "objectID": "courses/3501.4.html#p2-hag√°moslo-fps",
    "href": "courses/3501.4.html#p2-hag√°moslo-fps",
    "title": "Auxiliar 4",
    "section": "P2 ‚Äì Hag√°moslo FPS",
    "text": "P2 ‚Äì Hag√°moslo FPS\n\n\nParte A\nMuy bonita su escena pero hay elementos que no se ven completamente, como usted conoce ahora la potente matriz MVP, le gustar√≠a poder moverse en su escena.\n\n\nCree la clase Camara que contenga informaci√≥n de la posici√≥n de la c√°mara y su velocidad y use el teclado para moverse en la escena usando on_key_press y on_key_release"
  },
  {
    "objectID": "courses/3501.4.html#p2-hag√°moslo-fps-1",
    "href": "courses/3501.4.html#p2-hag√°moslo-fps-1",
    "title": "Auxiliar 4",
    "section": "P2 ‚Äì Hag√°moslo FPS",
    "text": "P2 ‚Äì Hag√°moslo FPS\n\n\nParte B\nA√±ada los valores de pitch y yaw que permitan mover la c√°mara, use la funci√≥n on_mouse_motion para vincular el √°ngulo de vista con el movimiento del mouse"
  },
  {
    "objectID": "courses/3501.4.html#p2-hag√°moslo-fps-2",
    "href": "courses/3501.4.html#p2-hag√°moslo-fps-2",
    "title": "Auxiliar 4",
    "section": "P2 ‚Äì Hag√°moslo FPS",
    "text": "P2 ‚Äì Hag√°moslo FPS\n\n\nParte C\nCorrija el movimiento de la parte A para que este sincronizado con la direcci√≥n de la c√°mara\n\n\n\n\n\n\n\n\n\nFelicidades! Ahora puedes hacer un 360 no scope ü§†"
  },
  {
    "objectID": "courses/4302.0.html",
    "href": "courses/4302.0.html",
    "title": "Sistemas operativos",
    "section": "",
    "text": "Introducci√≥n a Pthreads\nSincronizaci√≥n de Threads\nSem√°foros",
    "crumbs": [
      "Cursos",
      "2024",
      "Sistemas operativos"
    ]
  },
  {
    "objectID": "courses/4302.0.html#auxiliares",
    "href": "courses/4302.0.html#auxiliares",
    "title": "Sistemas operativos",
    "section": "",
    "text": "Introducci√≥n a Pthreads\nSincronizaci√≥n de Threads\nSem√°foros",
    "crumbs": [
      "Cursos",
      "2024",
      "Sistemas operativos"
    ]
  },
  {
    "objectID": "courses/4302.1.html#su-auxiliar",
    "href": "courses/4302.1.html#su-auxiliar",
    "title": "Auxiliar 1",
    "section": "Su auxiliar",
    "text": "Su auxiliar"
  },
  {
    "objectID": "courses/4302.1.html#su-auxiliar-1",
    "href": "courses/4302.1.html#su-auxiliar-1",
    "title": "Auxiliar 1",
    "section": "Su auxiliar",
    "text": "Su auxiliar\n\n\n\n\n\nVicente Gonz√°lez\nAuxiliar de\n\nPSS\nComputaci√≥n en GPU\nSistemas Operativos\nMetodolog√≠as de Dise√±o y Programaci√≥n\n\nSiempre disponible en persona üòÉ\nLento para responder correos üòü\nDoble titulaci√≥n\nNo duden en preguntar"
  },
  {
    "objectID": "courses/4302.1.html#section",
    "href": "courses/4302.1.html#section",
    "title": "Auxiliar 1",
    "section": "",
    "text": "Procesos Pesados\n\n\n\nFork\nNo comparten memoria\nCostosos de instanciar\nSeguros\n\n\n\n\nProcesos livianos\n\n\n\nPthreads\nComparten memoria\nBaratos de instanciar\nDatarraces"
  },
  {
    "objectID": "courses/4302.1.html#creaci√≥n-de-threads",
    "href": "courses/4302.1.html#creaci√≥n-de-threads",
    "title": "Auxiliar 1",
    "section": "Creaci√≥n de threads",
    "text": "Creaci√≥n de threads\nint pthread_create(pthread_t *thread, \n                   const pthread_attr_t *attr, \n                   void *(*start_routine)(void *), \n                   void *arg);\n\nCompuesto por:"
  },
  {
    "objectID": "courses/4302.1.html#creaci√≥n-de-threads-1",
    "href": "courses/4302.1.html#creaci√≥n-de-threads-1",
    "title": "Auxiliar 1",
    "section": "Creaci√≥n de threads",
    "text": "Creaci√≥n de threads\nint pthread_create(pthread_t *thread, \n                   const pthread_attr_t *attr, \n                   void *(*start_routine)(void *), \n                   void *arg);\nCompuesto por:\n\nLa referencia al proceso"
  },
  {
    "objectID": "courses/4302.1.html#creaci√≥n-de-threads-2",
    "href": "courses/4302.1.html#creaci√≥n-de-threads-2",
    "title": "Auxiliar 1",
    "section": "Creaci√≥n de threads",
    "text": "Creaci√≥n de threads\nint pthread_create(pthread_t *thread, \n                   const pthread_attr_t *attr, \n                   void *(*start_routine)(void *), \n                   void *arg);\nCompuesto por:\n\nLa referencia al proceso\nAtributos especiales del proceso (NULL)"
  },
  {
    "objectID": "courses/4302.1.html#creaci√≥n-de-threads-3",
    "href": "courses/4302.1.html#creaci√≥n-de-threads-3",
    "title": "Auxiliar 1",
    "section": "Creaci√≥n de threads",
    "text": "Creaci√≥n de threads\nint pthread_create(pthread_t *thread, \n                   const pthread_attr_t *attr, \n                   void *(*start_routine)(void *), \n                   void *arg);\nCompuesto por:\n\nLa referencia al proceso\nAtributos especiales del proceso (NULL)\nLa rutina a ejecutar por el proceso"
  },
  {
    "objectID": "courses/4302.1.html#creaci√≥n-de-threads-4",
    "href": "courses/4302.1.html#creaci√≥n-de-threads-4",
    "title": "Auxiliar 1",
    "section": "Creaci√≥n de threads",
    "text": "Creaci√≥n de threads\nint pthread_create(pthread_t *thread, \n                   const pthread_attr_t *attr, \n                   void *(*start_routine)(void *), \n                   void *arg);\nCompuesto por:\n\nLa referencia al proceso\nAtributos especiales del proceso (NULL)\nLa rutina a ejecutar por el proceso\nLos argumentos a pasar a la rutina"
  },
  {
    "objectID": "courses/4302.1.html#creaci√≥n-de-threads-5",
    "href": "courses/4302.1.html#creaci√≥n-de-threads-5",
    "title": "Auxiliar 1",
    "section": "Creaci√≥n de threads",
    "text": "Creaci√≥n de threads\nint pthread_create(pthread_t *thread, \n                   const pthread_attr_t *attr, \n                   void *(*start_routine)(void *), \n                   void *arg);\n\n\nRetorna 0 si la creaci√≥n fue exitosa\nEl thread termina cuando start_routine termina\nTodo thread creado debe ser enterrado con\nint pthread_join(pthread_t thread, void **return_value);\nLos thread no enterrados se convierte en zombies y no devuelven los recursos\nLa funci√≥n pthread_join espera a que el thread termine"
  },
  {
    "objectID": "courses/4302.1.html#ejemplo",
    "href": "courses/4302.1.html#ejemplo",
    "title": "Auxiliar 1",
    "section": "Ejemplo",
    "text": "Ejemplo\n#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n\nvoid *thread(void *ptr) {\n  char* nombre = (char*) ptr; // Castear argumento\n  printf(\"Thread - %s\\n\", nombre); // Trabajo en paralelo\n  return NULL; // Retorno\n}\n\nint main() {\n  pthread_t pid_1, pid_2; // Guardar PID de los threads lanzados\n  char* nombre_1 = \"primero\";\n  char* nombre_2 = \"segundo\";\n  pthread_create(&pid_1, NULL, thread, nombre_1); // lanzar thread1\n  pthread_create(&pid_2, NULL, thread, nombre_2); // lanzar thread2\n  pthread_join(pid_1, NULL); // esperar thread 1\n  pthread_join(pid_2, NULL); // esperar thread 2\n  return 0;\n}\n\n¬øC√≥mo puedo usar m√°s argumentos?\n\n\nUsamos una estructura!"
  },
  {
    "objectID": "courses/4302.1.html#ejemplo-1",
    "href": "courses/4302.1.html#ejemplo-1",
    "title": "Auxiliar 1",
    "section": "Ejemplo",
    "text": "Ejemplo\n#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n\ntypedef struct {\n  char* name;\n  int age;\n} Args;\n\nvoid *thread(void *ptr) {\n  char* nombre = (char*) ptr; // Castear argumento\n  printf(\"Thread - %s\\n\", nombre); // Trabajo en paralelo\n  return NULL; // Retorno\n}\n\nint main() {\n  pthread_t pid_1, pid_2; // Guardar PID de los threads lanzados\n  char* nombre_1 = \"primero\";\n  char* nombre_2 = \"segundo\";\n  pthread_create(&pid_1, NULL, thread, nombre_1); // lanzar thread1\n  pthread_create(&pid_2, NULL, thread, nombre_2); // lanzar thread2\n  pthread_join(pid_1, NULL); // esperar thread 1\n  pthread_join(pid_2, NULL); // esperar thread 2\n  return 0;\n}"
  },
  {
    "objectID": "courses/4302.1.html#ejemplo-2",
    "href": "courses/4302.1.html#ejemplo-2",
    "title": "Auxiliar 1",
    "section": "Ejemplo",
    "text": "Ejemplo\n#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n\ntypedef struct {\n  char* name;\n  int age;\n} Args;\n\nvoid *thread(void *ptr) {\n  char* nombre = (char*) ptr; // Castear argumento\n  printf(\"Thread - %s\\n\", nombre); // Trabajo en paralelo\n  return NULL; // Retorno\n}\n\nint main() {\n  pthread_t pid_1, pid_2; // Guardar PID de los threads lanzados\n  Args a1 = {\"primero\", 10} // inicializamos los args de t1\n  Args a2 = {\"segundo\", 20} // inicializamos los args de t2\n  pthread_create(&pid_1, NULL, thread, &a1); // la pasamos por referencia\n  pthread_create(&pid_2, NULL, thread, &a2); // la pasamos por referencia\n  pthread_join(pid_1, NULL); // esperar thread 1\n  pthread_join(pid_2, NULL); // esperar thread 2\n  return 0;\n}"
  },
  {
    "objectID": "courses/4302.1.html#ejemplo-3",
    "href": "courses/4302.1.html#ejemplo-3",
    "title": "Auxiliar 1",
    "section": "Ejemplo",
    "text": "Ejemplo\n#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n\ntypedef struct {\n  char* name;\n  int age;\n} Args;\n\nvoid *thread(void *ptr) {\n  Args* a = (Args*) ptr; // Castear a la estructura\n  printf(\"Thread - %s (%d)\\n\", a-&gt;name, a-&gt;age); // Accedemos a los miembros con -&gt;\n  return NULL; // Retorno\n}\n\nint main() {\n  pthread_t pid_1, pid_2; // Guardar PID de los threads lanzados\n  Args a1 = {\"primero\", 10} // inicializamos los args de t1\n  Args a2 = {\"segundo\", 20} // inicializamos los args de t2\n  pthread_create(&pid_1, NULL, thread, &a1); // la pasamos por referencia\n  pthread_create(&pid_2, NULL, thread, &a2); // la pasamos por referencia\n  pthread_join(pid_1, NULL); // esperar thread 1\n  pthread_join(pid_2, NULL); // esperar thread 2\n  return 0;\n}"
  },
  {
    "objectID": "courses/4302.1.html#how-to",
    "href": "courses/4302.1.html#how-to",
    "title": "Auxiliar 1",
    "section": "How to?",
    "text": "How to?\nDise√±o\n\n\nEncontrar las partes paralelizables\nCrear la estructura que permita ingresar los argumentos necesarios\nProgramar la rutina\n\n\n\n\nA veces la rutina s√≥lo ajusta los argumentos para llamar a otra funci√≥n\nEn la estructura de los argumentos podemos guardar cualquier cosa\n\n\nEsto es no pretende ser una receta, sino que una gu√≠a general"
  },
  {
    "objectID": "courses/4302.1.html#how-to-1",
    "href": "courses/4302.1.html#how-to-1",
    "title": "Auxiliar 1",
    "section": "How to?",
    "text": "How to?\nL√≥gica\n\n\nLanzar los threads con sus argumentos correspondientes\nSi aplica, realizar trabajo en el thread principal\nEsperar a que el trabajo paralelizado termine\nEnterrar los resultados y recolectar los resultados\n\n\n\n\nAntes del join no existe garant√≠a de que el trabajo se haya terminado\nAseg√∫rese de que exista paralelismo entre el create y el join\n\n\nEsto es no pretende ser una receta, sino que una gu√≠a general"
  },
  {
    "objectID": "courses/4302.1.html#p1-buscar-factor",
    "href": "courses/4302.1.html#p1-buscar-factor",
    "title": "Auxiliar 1",
    "section": "P1 ‚Äî Buscar Factor",
    "text": "P1 ‚Äî Buscar Factor\n\nParalelicemos esta funci√≥n que busca cualquier factor de un n√∫mero para acelerarla utilizando \\(P\\) cores\n\n\n#include &lt;pthread.h&gt;\n\ntypedef unsigned long long ulonglong;\ntypedef unsigned int uint;\n\n// busca un factor del n√∫mero entero x en el rango [i, j]\nuint buscarFactor(ulonglong x, uint i, uint j){\n    for (uint k = i; k &lt;= j; k++){\n        if (x % k == 0)\n            return k;\n    }\n    return 0;\n}\n\n\nDesaf√≠o: Lanzar \\(P-1\\) procesos y utilizar el principal en la b√∫squeda"
  },
  {
    "objectID": "courses/4302.1.html#p1-buscar-factor-1",
    "href": "courses/4302.1.html#p1-buscar-factor-1",
    "title": "Auxiliar 1",
    "section": "P1 ‚Äî Buscar Factor",
    "text": "P1 ‚Äî Buscar Factor\nPropuesto\n¬øC√≥mo har√≠as para que todos los procesos terminen cuando se encuentre el primer factor?\n#include &lt;pthread.h&gt;\n\ntypedef unsigned long long ulonglong;\ntypedef unsigned int uint;\n\n// busca un factor del n√∫mero entero x en el rango [i, j]\nuint buscarFactor(ulonglong x, uint i, uint j){\n    for (uint k = i; k &lt;= j; k++){\n        if (x % k == 0)\n            return k;\n    }\n    return 0;\n}\n\nHint: Quiz√°s una variable global ayudar√≠a"
  },
  {
    "objectID": "courses/4302.2.html#creaci√≥n-de-un-thread",
    "href": "courses/4302.2.html#creaci√≥n-de-un-thread",
    "title": "Auxiliar 2",
    "section": "Creaci√≥n de un thread",
    "text": "Creaci√≥n de un thread\nint pthread_create(pthread_t *thread, \n                   const pthread_attr_t *attr, \n                   void *(*start_routine)(void *), \n                   void *arg);\n\n\nLanza un nuevo thread que ejecuta start_routine.\nstart_routine recibe arg como argumento.\nEl thread se puede crear con atributos attr especiales (NULL).\nEl ‚ÄúID‚Äù del proceso se guarda en thread\nRetorna 0 si la creaci√≥n del proceso fue exitosa"
  },
  {
    "objectID": "courses/4302.2.html#t√©rmino-de-un-thread",
    "href": "courses/4302.2.html#t√©rmino-de-un-thread",
    "title": "Auxiliar 2",
    "section": "T√©rmino de un thread",
    "text": "T√©rmino de un thread\n\nUn thread termina si:\n\n\n\nRetorna start_routine.\nLlamando a pthread_exit (no recomendado).\nint pthread_exit(void *return_value);\n\n\n\nTodo thread cread debe ser enterrado con\nint pthread_join(pthread_t thread, void **return_value);\n\n\n\npthread_join espera a que el thread termine.\n\n\n\nLos thread no enterrados se convierte en zombies y no devuelven los recursos"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo",
    "href": "courses/4302.2.html#ejemplo",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\n#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n\nvoid *thread(void *ptr) {\n  char* nombre = (char*) ptr; // Castear argumento\n  printf(\"Thread - %s\\n\", nombre); // Trabajo en paralelo\n  return NULL; // Retorno\n}\n\nint main() {\n  pthread_t pid_1, pid_2; // Guardar PID de los threads lanzados\n  char* nombre_1 = \"primero\";\n  char* nombre_2 = \"segundo\";\n  pthread_create(&pid_1, NULL, thread, nombre_1); // lanzar thread1\n  pthread_create(&pid_2, NULL, thread, nombre_2); // lanzar thread2\n  pthread_join(pid_1, NULL); // esperar thread 1\n  pthread_join(pid_2, NULL); // esperar thread 2\n  return 0;\n}"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-m√∫ltiples-args",
    "href": "courses/4302.2.html#ejemplo-m√∫ltiples-args",
    "title": "Auxiliar 2",
    "section": "Ejemplo (m√∫ltiples args)",
    "text": "Ejemplo (m√∫ltiples args)\n#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n\ntypedef struct {\n  char* name;\n  int age;\n} Args;\n\nvoid *thread(void *ptr) {\n  Args* a = (Args*) ptr; // Castear a la estructura\n  printf(\"Thread - %s (%d)\\n\", a-&gt;name, a-&gt;age); // Accedemos a los miembros con -&gt;\n  return NULL; // Retorno\n}\n\nint main() {\n  pthread_t pid_1, pid_2; // Guardar PID de los threads lanzados\n  Args a1 = {\"primero\", 10} // inicializamos los args de t1\n  Args a2 = {\"segundo\", 20} // inicializamos los args de t2\n  pthread_create(&pid_1, NULL, thread, &a1); // la pasamos por referencia\n  pthread_create(&pid_2, NULL, thread, &a2); // la pasamos por referencia\n  pthread_join(pid_1, NULL); // esperar thread 1\n  pthread_join(pid_2, NULL); // esperar thread 2\n  return 0;\n}"
  },
  {
    "objectID": "courses/4302.2.html#how-to",
    "href": "courses/4302.2.html#how-to",
    "title": "Auxiliar 2",
    "section": "How to?",
    "text": "How to?\nDise√±o\n\n\nEncontrar las partes paralelizables\nCrear la estructura que permita ingresar los argumentos necesarios\nProgramar la rutina\n\n\n\n\nA veces la rutina s√≥lo ajusta los argumentos para llamar a otra funci√≥n\nEn la estructura de los argumentos podemos guardar cualquier cosa\n\n\n\n\nEsto es no pretende ser una receta, sino que una gu√≠a general"
  },
  {
    "objectID": "courses/4302.2.html#how-to-1",
    "href": "courses/4302.2.html#how-to-1",
    "title": "Auxiliar 2",
    "section": "How to?",
    "text": "How to?\nL√≥gica\n\n\nLanzar los threads con sus argumentos correspondientes\nSi aplica, realizar trabajo en el thread principal\nEsperar a que el trabajo paralelizado termine\nEnterrar los resultados y recolectar los resultados\n\n\n\n\nAntes del join no existe garant√≠a de que el trabajo se haya terminado\nAseg√∫rese de que exista paralelismo entre el create y el join\n\n\n\n\nEsto es no pretende ser una receta, sino que una gu√≠a general"
  },
  {
    "objectID": "courses/4302.2.html#p1-quicksort-paralelo",
    "href": "courses/4302.2.html#p1-quicksort-paralelo",
    "title": "Auxiliar 2",
    "section": "P1 ‚Äî Quicksort paralelo",
    "text": "P1 ‚Äî Quicksort paralelo\nLa siguiente funci√≥n es una implementaci√≥n simple de quicksort:\n#include &lt;pthread.h&gt;\n\nvoid quicksort_seq(int a[], int i, int j) {\n    if (i &lt; j) {\n        int h = particionar(a, i, j);\n        quicksort_seq(a, i, h - 1);\n        quicksort_seq(a. h + 1, j);\n    }\n}\n\n\nConsidere particionar como la funci√≥n que selecciona el pivote y reordena el arreglo.\nLos valores menores al pivote quedan a la izquierda y los mayores a la derecha.\nSe le pide paralelizar la funci√≥n tal que haga uso de \\(N\\) cores:\nvoid quicksort(int a[], int i, int j, int n);\n\n\n\nIdea\nInvocaciones secuenciales independientes son directamente paralelizables"
  },
  {
    "objectID": "courses/4302.2.html#la-nueva-pesadilla",
    "href": "courses/4302.2.html#la-nueva-pesadilla",
    "title": "Auxiliar 2",
    "section": "La nueva pesadilla",
    "text": "La nueva pesadilla\n\nCuando se trabaja en paralelo, nacen nuevos enemigos.\n\n\nAl acceder a recursos compartidos desde varios procesos se pueden generar problemas como:\n\n\n\nDataraces\nVariables se sobreescriben\nRace conditions\nOrden incorrecto de ejecuci√≥n\nHambruna y Deadlocks\nUn proceso no obtiene tiempo de ejecuci√≥n"
  },
  {
    "objectID": "courses/4302.2.html#la-soluci√≥n",
    "href": "courses/4302.2.html#la-soluci√≥n",
    "title": "Auxiliar 2",
    "section": "La soluci√≥n",
    "text": "La soluci√≥n\n\n\nMutex\n\n\n\nMUTual EXclusi√≥n\n\n\nGarantiza la exclusi√≥n mutua, bloqueando el acceso a ‚Äúzonas cr√≠ticas‚Äù, las cuales son zonas del c√≥digo donde se manipulan los recursos compartidos.\n\n\n\n\nCondiciones\n\n\nHacen esperar a los procesos de manera eficiente hasta que se cumpla la condici√≥n para continuar la ejecuci√≥n."
  },
  {
    "objectID": "courses/4302.2.html#manejo",
    "href": "courses/4302.2.html#manejo",
    "title": "Auxiliar 2",
    "section": "Manejo",
    "text": "Manejo\n\n\nInicializaci√≥n\n\n\n\n\nUsando macros\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n\nDentro de una funci√≥n\npthread_mutex_t mutex;\n// ...\npthread_mutex_init(&mutex, NULL);\n\n\n\n\nUso\n\n\nPara solicitar el mutex:\nint pthread_mutex_lock(pthread_mutex_t *mutex); \nLa funci√≥n retorna solo para el primer proceso que pida el mutex, el resto queda esperando\n\n\nPara liberar el mutex:\nint pthread_mutex_unlock(pthread_mutex_t *mutex); \nAl liberar el mutex, todos los procesos se despiertan a la vez, no esta garantizado el orden de adquisici√≥n"
  },
  {
    "objectID": "courses/4302.2.html#comportamiento",
    "href": "courses/4302.2.html#comportamiento",
    "title": "Auxiliar 2",
    "section": "Comportamiento",
    "text": "Comportamiento\n\n\nUn mutex garantiza que s√≥lo un proceso pueda entrar a una su ‚Äúzona cr√≠tica‚Äù de c√≥digo.\nDebe ser solicitado para ingresar y liberado al salir.\nDos estados posibles:\n\n\n\nAbierto\nNing√∫n proceso ha solicitado el mutex\n\nCerrado\nAlg√∫n proceso ha solicitado el mutex y no ha sido liberado\n\n\nSi un proceso intenta solicitar un mutex cerrado, este ser√° suspendido hasta que el mutex sea liberado."
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-1",
    "href": "courses/4302.2.html#ejemplo-1",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\nint contador = 0;\nvoid aumentar_cont() {\n  contador++;\n}\n\nMala implementaci√≥n ü§¢\n\n\n\n¬øD√≥nde esta el error?\n\n\nHagamos un diagrama"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-2",
    "href": "courses/4302.2.html#ejemplo-2",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\npthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;\nint contador = 0;\nvoid aumentar_cont() {\n  pthread_mutex_lock(&m);\n  contador++;\n  pthread_mutex_unlock(&m);\n}\n\nBuena implementaci√≥n ü§†\n\n\n\nRepitamos el diagrama"
  },
  {
    "objectID": "courses/4302.2.html#motivaci√≥n",
    "href": "courses/4302.2.html#motivaci√≥n",
    "title": "Auxiliar 2",
    "section": "Motivaci√≥n",
    "text": "Motivaci√≥n\n\nUna forma de esperar podr√≠a ser:\nwhile (ocupado) {\n    ; // wait\n}\n\n\nEsto es mala idea porque mantiene ocupado al core\n\n\nEs mejor ‚Äúdormir‚Äù el proceso para desocupar el core"
  },
  {
    "objectID": "courses/4302.2.html#manejo-1",
    "href": "courses/4302.2.html#manejo-1",
    "title": "Auxiliar 2",
    "section": "Manejo",
    "text": "Manejo\n\n\nInicializaci√≥n\n\n\n\n\nUsando macros\npthread_cond_t mutex = PTHREAD_COND_INITIALIZER;\n\nDentro de una funci√≥n\npthread_cond_t cond;\n// ...\npthread_cond_init(&cond, NULL);\n\n\n\n\nUso\n\n\nPara hacer esperar a un proceso:\nint pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex); \nAl entrar en espera, el proceso liberar√° el mutex\nAl salir de espera, el proceso esperar√° el mutex y la funci√≥n retornar√° cuando lo obtenga\n\n\nPara despertar procesos:\nint pthread_cond_broadcast(pthread_cond_t *cond); // despertar a todos\nint pthread_cond_signal(pthread_cond_t *cond); // despertar uno (cualquiera)"
  },
  {
    "objectID": "courses/4302.2.html#comportamiento-1",
    "href": "courses/4302.2.html#comportamiento-1",
    "title": "Auxiliar 2",
    "section": "Comportamiento",
    "text": "Comportamiento\n\n\nLa espera es eficiente, dejando disponible el core.\nLa funci√≥n wait se hace cargo de liberar y pedir el mutex asociado.\nLa funci√≥n broadcast despierta a todos los procesos en espera.\nLa funci√≥n signal despierta a un solo proceso sin orden garantizado.\nUn proceso que esperaba por una condici√≥n puede quedar en espera por un mutex."
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-3",
    "href": "courses/4302.2.html#ejemplo-3",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    while(contador &lt; 10) {;}\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg√≥ a 10\");\n    return 0;\n}\n\nMala implementaci√≥n ü§¢"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-4",
    "href": "courses/4302.2.html#ejemplo-4",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    while(contador &lt; 10) {;}\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg√≥ a 10\");\n    return 0;\n}\nBusy waiting"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-5",
    "href": "courses/4302.2.html#ejemplo-5",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    while(contador &lt; 10) {;}\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg√≥ a 10\");\n    return 0;\n}\nHambruna\n\n\nToma el mutex y no lo libera antes de esperar\nNo es Deadlock porque el primer proceso est√° despierto"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-6",
    "href": "courses/4302.2.html#ejemplo-6",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    if(contador == 10){\n        pthread_cond_broadcast(&cond);\n    }\n    while(contador &lt; 10){\n        pthread_cond_wait(&cond, &mutex);\n    }\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg√≥ a 10\");\n    return 0; \n}"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-7",
    "href": "courses/4302.2.html#ejemplo-7",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    if(contador == 10){\n        pthread_cond_broadcast(&cond);\n    }\n    while(contador &lt; 10){\n        pthread_cond_wait(&cond, &mutex);\n    }\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg√≥ a 10\");\n    return 0; \n}\nCondiciones a√±adidas"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-8",
    "href": "courses/4302.2.html#ejemplo-8",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    if(contador == 10){\n        pthread_cond_broadcast(&cond);\n    }\n    while(contador &lt; 10){\n        pthread_cond_wait(&cond, &mutex);\n    }\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg√≥ a 10\");\n    return 0; \n}\nEspera eficiente"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-9",
    "href": "courses/4302.2.html#ejemplo-9",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    if(contador == 10){\n        pthread_cond_broadcast(&cond);\n    }\n    while(contador &lt; 10){\n        pthread_cond_wait(&cond, &mutex);\n    }\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg√≥ a 10\");\n    return 0; \n}\nZona cr√≠tica respetada"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-10",
    "href": "courses/4302.2.html#ejemplo-10",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    if(contador == 10){\n        pthread_cond_broadcast(&cond);\n    }\n    while(contador &lt; 10){\n        pthread_cond_wait(&cond, &mutex);\n    }\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg√≥ a 10\");\n    return 0; \n}\nBuena implementaci√≥n ü§†"
  },
  {
    "objectID": "courses/4302.2.html#p2-colecta",
    "href": "courses/4302.2.html#p2-colecta",
    "title": "Auxiliar 2",
    "section": "P2 ‚Äî Colecta",
    "text": "P2 ‚Äî Colecta\nSe necesita crear un sistemas para juntar exactamente una cantidad \\(X\\) de dinero:\n\n\nDefinir el tipo de datos Colecta.\nProgramar la funci√≥n\nColecta *nuevaColecta(double meta);\nQue crea y retorna una colecta para juntar meta pesos.\nProgramar la funci√≥n\ndouble aportar(Colecta *c, double monto);\nQue es invocada desde m√∫ltiples procesos para contribuir monto pesos. El valor de retorno de la funci√≥n es el m√≠nimo entre monto y lo que falta para llegar a la meta.\nLa funci√≥n retornar una vez que la meta se cumpla"
  },
  {
    "objectID": "courses/index.html",
    "href": "courses/index.html",
    "title": "Cursos",
    "section": "",
    "text": "Aqu√≠ esta el material de cursos que he dictado",
    "crumbs": [
      "Cursos",
      "2024"
    ]
  }
]