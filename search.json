[
  {
    "objectID": "courses/3501.0.html",
    "href": "courses/3501.0.html",
    "title": "Modelaci√≥n y Computaci√≥n Gr√°fica para Ingeniero",
    "section": "",
    "text": "Instalaci√≥n de Herramientas",
    "crumbs": [
      "Cursos",
      "2024",
      "Modelaci√≥n y Computaci√≥n Gr√°fica para Ingeniero"
    ]
  },
  {
    "objectID": "courses/3501.0.html#auxiliares",
    "href": "courses/3501.0.html#auxiliares",
    "title": "Modelaci√≥n y Computaci√≥n Gr√°fica para Ingeniero",
    "section": "",
    "text": "Instalaci√≥n de Herramientas",
    "crumbs": [
      "Cursos",
      "2024",
      "Modelaci√≥n y Computaci√≥n Gr√°fica para Ingeniero"
    ]
  },
  {
    "objectID": "courses/4302.1.html#su-auxiliar",
    "href": "courses/4302.1.html#su-auxiliar",
    "title": "Auxiliar 1",
    "section": "Su auxiliar",
    "text": "Su auxiliar"
  },
  {
    "objectID": "courses/4302.1.html#su-auxiliar-1",
    "href": "courses/4302.1.html#su-auxiliar-1",
    "title": "Auxiliar 1",
    "section": "Su auxiliar",
    "text": "Su auxiliar\n\n\n\n\n\nVicente Gonz√°lez\nAuxiliar de\n\nPSS\nComputaci√≥n en GPU\nSistemas Operativos\nMetodolog√≠as de Dise√±o y Programaci√≥n\n\nSiempre disponible en persona üòÉ\nLento para responder correos üòü\nDoble titulaci√≥n\nNo duden en preguntar"
  },
  {
    "objectID": "courses/4302.1.html#section",
    "href": "courses/4302.1.html#section",
    "title": "Auxiliar 1",
    "section": "",
    "text": "Procesos Pesados\n\n\n\nFork\nNo comparten memoria\nCostosos de instanciar\nSeguros\n\n\n\n\nProcesos livianos\n\n\n\nPthreads\nComparten memoria\nBaratos de instanciar\nDatarraces"
  },
  {
    "objectID": "courses/4302.1.html#creaci√≥n-de-threads",
    "href": "courses/4302.1.html#creaci√≥n-de-threads",
    "title": "Auxiliar 1",
    "section": "Creaci√≥n de threads",
    "text": "Creaci√≥n de threads\nint pthread_create(pthread_t *thread, \n                   const pthread_attr_t *attr, \n                   void *(*start_routine)(void *), \n                   void *arg);\n\nCompuesto por:"
  },
  {
    "objectID": "courses/4302.1.html#creaci√≥n-de-threads-1",
    "href": "courses/4302.1.html#creaci√≥n-de-threads-1",
    "title": "Auxiliar 1",
    "section": "Creaci√≥n de threads",
    "text": "Creaci√≥n de threads\nint pthread_create(pthread_t *thread, \n                   const pthread_attr_t *attr, \n                   void *(*start_routine)(void *), \n                   void *arg);\nCompuesto por:\n\nLa referencia al proceso"
  },
  {
    "objectID": "courses/4302.1.html#creaci√≥n-de-threads-2",
    "href": "courses/4302.1.html#creaci√≥n-de-threads-2",
    "title": "Auxiliar 1",
    "section": "Creaci√≥n de threads",
    "text": "Creaci√≥n de threads\nint pthread_create(pthread_t *thread, \n                   const pthread_attr_t *attr, \n                   void *(*start_routine)(void *), \n                   void *arg);\nCompuesto por:\n\nLa referencia al proceso\nAtributos especiales del proceso (NULL)"
  },
  {
    "objectID": "courses/4302.1.html#creaci√≥n-de-threads-3",
    "href": "courses/4302.1.html#creaci√≥n-de-threads-3",
    "title": "Auxiliar 1",
    "section": "Creaci√≥n de threads",
    "text": "Creaci√≥n de threads\nint pthread_create(pthread_t *thread, \n                   const pthread_attr_t *attr, \n                   void *(*start_routine)(void *), \n                   void *arg);\nCompuesto por:\n\nLa referencia al proceso\nAtributos especiales del proceso (NULL)\nLa rutina a ejecutar por el proceso"
  },
  {
    "objectID": "courses/4302.1.html#creaci√≥n-de-threads-4",
    "href": "courses/4302.1.html#creaci√≥n-de-threads-4",
    "title": "Auxiliar 1",
    "section": "Creaci√≥n de threads",
    "text": "Creaci√≥n de threads\nint pthread_create(pthread_t *thread, \n                   const pthread_attr_t *attr, \n                   void *(*start_routine)(void *), \n                   void *arg);\nCompuesto por:\n\nLa referencia al proceso\nAtributos especiales del proceso (NULL)\nLa rutina a ejecutar por el proceso\nLos argumentos a pasar a la rutina"
  },
  {
    "objectID": "courses/4302.1.html#creaci√≥n-de-threads-5",
    "href": "courses/4302.1.html#creaci√≥n-de-threads-5",
    "title": "Auxiliar 1",
    "section": "Creaci√≥n de threads",
    "text": "Creaci√≥n de threads\nint pthread_create(pthread_t *thread, \n                   const pthread_attr_t *attr, \n                   void *(*start_routine)(void *), \n                   void *arg);\n\n\nRetorna 0 si la creaci√≥n fue exitosa\nEl thread termina cuando start_routine termina\nTodo thread creado debe ser enterrado con\nint pthread_join(pthread_t thread, void **return_value);\nLos thread no enterrados se convierte en zombies y no devuelven los recursos\nLa funci√≥n pthread_join espera a que el thread termine"
  },
  {
    "objectID": "courses/4302.1.html#ejemplo",
    "href": "courses/4302.1.html#ejemplo",
    "title": "Auxiliar 1",
    "section": "Ejemplo",
    "text": "Ejemplo\n#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n\nvoid *thread(void *ptr) {\n  char* nombre = (char*) ptr; // Castear argumento\n  printf(\"Thread - %s\\n\", nombre); // Trabajo en paralelo\n  return NULL; // Retorno\n}\n\nint main() {\n  pthread_t pid_1, pid_2; // Guardar PID de los threads lanzados\n  char* nombre_1 = \"primero\";\n  char* nombre_2 = \"segundo\";\n  pthread_create(&pid_1, NULL, thread, nombre_1); // lanzar thread1\n  pthread_create(&pid_2, NULL, thread, nombre_2); // lanzar thread2\n  pthread_join(pid_1, NULL); // esperar thread 1\n  pthread_join(pid_2, NULL); // esperar thread 2\n  return 0;\n}\n\n¬øC√≥mo puedo usar m√°s argumentos?\n\n\nUsamos una estructura!"
  },
  {
    "objectID": "courses/4302.1.html#ejemplo-1",
    "href": "courses/4302.1.html#ejemplo-1",
    "title": "Auxiliar 1",
    "section": "Ejemplo",
    "text": "Ejemplo\n#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n\ntypedef struct {\n  char* name;\n  int age;\n} Args;\n\nvoid *thread(void *ptr) {\n  char* nombre = (char*) ptr; // Castear argumento\n  printf(\"Thread - %s\\n\", nombre); // Trabajo en paralelo\n  return NULL; // Retorno\n}\n\nint main() {\n  pthread_t pid_1, pid_2; // Guardar PID de los threads lanzados\n  char* nombre_1 = \"primero\";\n  char* nombre_2 = \"segundo\";\n  pthread_create(&pid_1, NULL, thread, nombre_1); // lanzar thread1\n  pthread_create(&pid_2, NULL, thread, nombre_2); // lanzar thread2\n  pthread_join(pid_1, NULL); // esperar thread 1\n  pthread_join(pid_2, NULL); // esperar thread 2\n  return 0;\n}"
  },
  {
    "objectID": "courses/4302.1.html#ejemplo-2",
    "href": "courses/4302.1.html#ejemplo-2",
    "title": "Auxiliar 1",
    "section": "Ejemplo",
    "text": "Ejemplo\n#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n\ntypedef struct {\n  char* name;\n  int age;\n} Args;\n\nvoid *thread(void *ptr) {\n  char* nombre = (char*) ptr; // Castear argumento\n  printf(\"Thread - %s\\n\", nombre); // Trabajo en paralelo\n  return NULL; // Retorno\n}\n\nint main() {\n  pthread_t pid_1, pid_2; // Guardar PID de los threads lanzados\n  Args a1 = {\"primero\", 10} // inicializamos los args de t1\n  Args a2 = {\"segundo\", 20} // inicializamos los args de t2\n  pthread_create(&pid_1, NULL, thread, &a1); // la pasamos por referencia\n  pthread_create(&pid_2, NULL, thread, &a2); // la pasamos por referencia\n  pthread_join(pid_1, NULL); // esperar thread 1\n  pthread_join(pid_2, NULL); // esperar thread 2\n  return 0;\n}"
  },
  {
    "objectID": "courses/4302.1.html#ejemplo-3",
    "href": "courses/4302.1.html#ejemplo-3",
    "title": "Auxiliar 1",
    "section": "Ejemplo",
    "text": "Ejemplo\n#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n\ntypedef struct {\n  char* name;\n  int age;\n} Args;\n\nvoid *thread(void *ptr) {\n  Args* a = (Args*) ptr; // Castear a la estructura\n  printf(\"Thread - %s (%d)\\n\", a-&gt;name, a-&gt;age); // Accedemos a los miembros con -&gt;\n  return NULL; // Retorno\n}\n\nint main() {\n  pthread_t pid_1, pid_2; // Guardar PID de los threads lanzados\n  Args a1 = {\"primero\", 10} // inicializamos los args de t1\n  Args a2 = {\"segundo\", 20} // inicializamos los args de t2\n  pthread_create(&pid_1, NULL, thread, &a1); // la pasamos por referencia\n  pthread_create(&pid_2, NULL, thread, &a2); // la pasamos por referencia\n  pthread_join(pid_1, NULL); // esperar thread 1\n  pthread_join(pid_2, NULL); // esperar thread 2\n  return 0;\n}"
  },
  {
    "objectID": "courses/4302.1.html#how-to",
    "href": "courses/4302.1.html#how-to",
    "title": "Auxiliar 1",
    "section": "How to?",
    "text": "How to?\nDise√±o\n\n\nEncontrar las partes paralelizables\nCrear la estructura que permita ingresar los argumentos necesarios\nProgramar la rutina\n\n\n\n\nA veces la rutina s√≥lo ajusta los argumentos para llamar a otra funci√≥n\nEn la estructura de los argumentos podemos guardar cualquier cosa\n\n\nEsto es no pretende ser una receta, sino que una gu√≠a general"
  },
  {
    "objectID": "courses/4302.1.html#how-to-1",
    "href": "courses/4302.1.html#how-to-1",
    "title": "Auxiliar 1",
    "section": "How to?",
    "text": "How to?\nL√≥gica\n\n\nLanzar los threads con sus argumentos correspondientes\nSi aplica, realizar trabajo en el thread principal\nEsperar a que el trabajo paralelizado termine\nEnterrar los resultados y recolectar los resultados\n\n\n\n\nAntes del join no existe garant√≠a de que el trabajo se haya terminado\nAseg√∫rese de que exista paralelismo entre el create y el join\n\n\nEsto es no pretende ser una receta, sino que una gu√≠a general"
  },
  {
    "objectID": "courses/4302.1.html#p1-buscar-factor",
    "href": "courses/4302.1.html#p1-buscar-factor",
    "title": "Auxiliar 1",
    "section": "P1 ‚Äî Buscar Factor",
    "text": "P1 ‚Äî Buscar Factor\n\nParalelicemos esta funci√≥n que busca cualquier factor de un n√∫mero para acelerarla utilizando \\(P\\) cores\n\n\n#include &lt;pthread.h&gt;\n\ntypedef unsigned long long ulonglong;\ntypedef unsigned int uint;\n\n// busca un factor del n√∫mero entero x en el rango [i, j]\nuint buscarFactor(ulonglong x, uint i, uint j){\n    for (uint k = i; k &lt;= j; k++){\n        if (x % k == 0)\n            return k;\n    }\n    return 0;\n}\n\n\nDesaf√≠o: Lanzar \\(P-1\\) procesos y utilizar el principal en la b√∫squeda"
  },
  {
    "objectID": "courses/4302.1.html#p1-buscar-factor-1",
    "href": "courses/4302.1.html#p1-buscar-factor-1",
    "title": "Auxiliar 1",
    "section": "P1 ‚Äî Buscar Factor",
    "text": "P1 ‚Äî Buscar Factor\nPropuesto\n¬øC√≥mo har√≠as para que todos los procesos terminen cuando se encuentre el primer factor?\n#include &lt;pthread.h&gt;\n\ntypedef unsigned long long ulonglong;\ntypedef unsigned int uint;\n\n// busca un factor del n√∫mero entero x en el rango [i, j]\nuint buscarFactor(ulonglong x, uint i, uint j){\n    for (uint k = i; k &lt;= j; k++){\n        if (x % k == 0)\n            return k;\n    }\n    return 0;\n}\n\nHint: Quiz√°s una variable global ayudar√≠a"
  },
  {
    "objectID": "courses/3501.1.html#su-auxiliar",
    "href": "courses/3501.1.html#su-auxiliar",
    "title": "Auxiliar 1",
    "section": "Su auxiliar",
    "text": "Su auxiliar\n\n\n\n\nVicente Gonz√°lez\nAuxiliar de\n\nPSS\nComputaci√≥n en GPU\nSistemas Operativos\nMetodolog√≠as de Dise√±o y Programaci√≥n\n\nSiempre disponible en persona üòÉ\nLento para responder correos üòü\nDoble titulaci√≥n\nNo duden en preguntar"
  },
  {
    "objectID": "courses/3501.1.html#terminal",
    "href": "courses/3501.1.html#terminal",
    "title": "Auxiliar 1",
    "section": "Terminal",
    "text": "Terminal\nAlgunas cosas para manejarse mejor\n\n\n\n\n\n\n\nComando\nDescripci√≥n\n\n\n\n\ncd &lt;ruta&gt;\n¬†Cambia al directorio &lt;ruta&gt;\n\n\nls/dir\n¬†Lista los archivos y directorios en el directorio actual\n\n\nmdkir &lt;nombre&gt;\n¬†Crea un directorio nuevo llamado &lt;nombre&gt;\n\n\nmv &lt;desde&gt; &lt;hacia&gt;\n¬†Mueve un archivo/directorio &lt;desde&gt; a una ruta &lt;hacia&gt;\n\n\nrm &lt;nombre&gt;1\n¬†Elimina/borra el archivo &lt;nombre&gt;\n\n\n\n\n\nPueden abusar del Tab para que les autocomplete y agregar --help para que les explique\nPueden agregar la flag -rf para borrar carpetas enteras"
  },
  {
    "objectID": "courses/3501.1.html#python",
    "href": "courses/3501.1.html#python",
    "title": "Auxiliar 1",
    "section": "Python",
    "text": "Python"
  },
  {
    "objectID": "courses/3501.1.html#pip",
    "href": "courses/3501.1.html#pip",
    "title": "Auxiliar 1",
    "section": "PIP",
    "text": "PIP\n\n\nGestor de paquetes de Python\nViene instalado con su versi√≥n de Python\nPaquetes como venv permiten gestionar ambientes\n\n\n\n\nDetalles de la instalaci√≥n aqui"
  },
  {
    "objectID": "courses/3501.1.html#pip-1",
    "href": "courses/3501.1.html#pip-1",
    "title": "Auxiliar 1",
    "section": "PIP",
    "text": "PIP\n\n\nPara crear ambientes (se crea en la carpeta .venv)\npython -m venv venv\nPara activarlo\nsource ./venv/bin/activate\nInstalar paquetes\npip install &lt;paquete&gt;\npip install -r &lt;archivo&gt;\n\n\n\n\nDetalles de la instalaci√≥n aqui"
  },
  {
    "objectID": "courses/3501.1.html#conda",
    "href": "courses/3501.1.html#conda",
    "title": "Auxiliar 1",
    "section": "Conda",
    "text": "Conda\n\n\nAlternativa a PIP\nGestor de paquetes del sistemas\nIncorpora ambientes\nRecomiendo Miniconda\n\n\n\n\nDudas con la instalaci√≥n por correo"
  },
  {
    "objectID": "courses/3501.1.html#conda-1",
    "href": "courses/3501.1.html#conda-1",
    "title": "Auxiliar 1",
    "section": "Conda",
    "text": "Conda\n\n\nPara crear ambientes\nconda env create -n &lt;nombre&gt; \nPara activarlo\nconda activate &lt;nombre&gt;\nInstalar paquetes\nconda install &lt;paquete&gt;\n\n\n\n\nDudas con la instalaci√≥n por correo"
  },
  {
    "objectID": "courses/3501.1.html#editor",
    "href": "courses/3501.1.html#editor",
    "title": "Auxiliar 1",
    "section": "Editor",
    "text": "Editor"
  },
  {
    "objectID": "courses/3501.1.html#vscode",
    "href": "courses/3501.1.html#vscode",
    "title": "Auxiliar 1",
    "section": "VSCode",
    "text": "VSCode\n\n\nSencillo y liviano\nUsa extensiones\nMicrosoft ü§¢\nGratis ü§ë\n\n\n\nDescargar"
  },
  {
    "objectID": "courses/3501.1.html#pycharm",
    "href": "courses/3501.1.html#pycharm",
    "title": "Auxiliar 1",
    "section": "PyCharm",
    "text": "PyCharm\n\n\nCompleto\nUsa plugins\nJetBrains ü§¢\nGratis (Community) y de Pago1 (Professional)\n\n\n\nDescargar\n\nSe puede obtener gratis con una licencia educacional"
  },
  {
    "objectID": "courses/3501.1.html#vim",
    "href": "courses/3501.1.html#vim",
    "title": "Auxiliar 1",
    "section": "Vim",
    "text": "Vim\n\n\nUltra liviano pero ultra extensible\nOpen Source\nLo usa el admin (yo üòé)\nMuy dif√≠cil, no recomendado\n\n\n\nDescargar"
  },
  {
    "objectID": "courses/3501.1.html#git",
    "href": "courses/3501.1.html#git",
    "title": "Auxiliar 1",
    "section": "Git",
    "text": "Git\n\n\n\n\nPara clonar repositorios\ngit clone &lt;url&gt; &lt;nombre_carpeta&gt;\nNO es necesario para el curso\nTutorial\n\n\n\n\n\n\n\n\n\n\n\nDetalles de la instalaci√≥n aqui"
  },
  {
    "objectID": "courses/3501.1.html#hello-world",
    "href": "courses/3501.1.html#hello-world",
    "title": "Auxiliar 1",
    "section": "Hello world!",
    "text": "Hello world!\n\n\n\n\n\n\n¬øCambiemos el color?"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Inicio",
    "section": "",
    "text": "Bienvenido üòÉ"
  },
  {
    "objectID": "courses/4302.0.html",
    "href": "courses/4302.0.html",
    "title": "Sistemas operativos",
    "section": "",
    "text": "Introducci√≥n a Pthreads\nSincronizaci√≥n de Threads",
    "crumbs": [
      "Cursos",
      "2024",
      "Sistemas operativos"
    ]
  },
  {
    "objectID": "courses/4302.0.html#auxiliares",
    "href": "courses/4302.0.html#auxiliares",
    "title": "Sistemas operativos",
    "section": "",
    "text": "Introducci√≥n a Pthreads\nSincronizaci√≥n de Threads",
    "crumbs": [
      "Cursos",
      "2024",
      "Sistemas operativos"
    ]
  },
  {
    "objectID": "courses/4302.2.html#creaci√≥n-de-un-thread",
    "href": "courses/4302.2.html#creaci√≥n-de-un-thread",
    "title": "Auxiliar 2",
    "section": "Creaci√≥n de un thread",
    "text": "Creaci√≥n de un thread\nint pthread_create(pthread_t *thread, \n                   const pthread_attr_t *attr, \n                   void *(*start_routine)(void *), \n                   void *arg);\n\n\nLanza un nuevo thread que ejecuta start_routine.\nstart_routine recibe arg como argumento.\nEl thread se puede crear con atributos attr especiales (NULL).\nEl ‚ÄúID‚Äù del proceso se guarda en thread\nRetorna 0 si la creaci√≥n del proceso fue exitosa"
  },
  {
    "objectID": "courses/4302.2.html#t√©rmino-de-un-thread",
    "href": "courses/4302.2.html#t√©rmino-de-un-thread",
    "title": "Auxiliar 2",
    "section": "T√©rmino de un thread",
    "text": "T√©rmino de un thread\n\nUn thread termina si:\n\n\n\nRetorna start_routine.\nLlamando a pthread_exit (no recomendado).\nint pthread_exit(void *return_value);\n\n\n\nTodo thread cread debe ser enterrado con\nint pthread_join(pthread_t thread, void **return_value);\n\n\n\npthread_join espera a que el thread termine.\n\n\n\nLos thread no enterrados se convierte en zombies y no devuelven los recursos"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo",
    "href": "courses/4302.2.html#ejemplo",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\n#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n\nvoid *thread(void *ptr) {\n  char* nombre = (char*) ptr; // Castear argumento\n  printf(\"Thread - %s\\n\", nombre); // Trabajo en paralelo\n  return NULL; // Retorno\n}\n\nint main() {\n  pthread_t pid_1, pid_2; // Guardar PID de los threads lanzados\n  char* nombre_1 = \"primero\";\n  char* nombre_2 = \"segundo\";\n  pthread_create(&pid_1, NULL, thread, nombre_1); // lanzar thread1\n  pthread_create(&pid_2, NULL, thread, nombre_2); // lanzar thread2\n  pthread_join(pid_1, NULL); // esperar thread 1\n  pthread_join(pid_2, NULL); // esperar thread 2\n  return 0;\n}"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-m√∫ltiples-args",
    "href": "courses/4302.2.html#ejemplo-m√∫ltiples-args",
    "title": "Auxiliar 2",
    "section": "Ejemplo (m√∫ltiples args)",
    "text": "Ejemplo (m√∫ltiples args)\n#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n\ntypedef struct {\n  char* name;\n  int age;\n} Args;\n\nvoid *thread(void *ptr) {\n  Args* a = (Args*) ptr; // Castear a la estructura\n  printf(\"Thread - %s (%d)\\n\", a-&gt;name, a-&gt;age); // Accedemos a los miembros con -&gt;\n  return NULL; // Retorno\n}\n\nint main() {\n  pthread_t pid_1, pid_2; // Guardar PID de los threads lanzados\n  Args a1 = {\"primero\", 10} // inicializamos los args de t1\n  Args a2 = {\"segundo\", 20} // inicializamos los args de t2\n  pthread_create(&pid_1, NULL, thread, &a1); // la pasamos por referencia\n  pthread_create(&pid_2, NULL, thread, &a2); // la pasamos por referencia\n  pthread_join(pid_1, NULL); // esperar thread 1\n  pthread_join(pid_2, NULL); // esperar thread 2\n  return 0;\n}"
  },
  {
    "objectID": "courses/4302.2.html#how-to",
    "href": "courses/4302.2.html#how-to",
    "title": "Auxiliar 2",
    "section": "How to?",
    "text": "How to?\nDise√±o\n\n\nEncontrar las partes paralelizables\nCrear la estructura que permita ingresar los argumentos necesarios\nProgramar la rutina\n\n\n\n\nA veces la rutina s√≥lo ajusta los argumentos para llamar a otra funci√≥n\nEn la estructura de los argumentos podemos guardar cualquier cosa\n\n\n\n\nEsto es no pretende ser una receta, sino que una gu√≠a general"
  },
  {
    "objectID": "courses/4302.2.html#how-to-1",
    "href": "courses/4302.2.html#how-to-1",
    "title": "Auxiliar 2",
    "section": "How to?",
    "text": "How to?\nL√≥gica\n\n\nLanzar los threads con sus argumentos correspondientes\nSi aplica, realizar trabajo en el thread principal\nEsperar a que el trabajo paralelizado termine\nEnterrar los resultados y recolectar los resultados\n\n\n\n\nAntes del join no existe garant√≠a de que el trabajo se haya terminado\nAseg√∫rese de que exista paralelismo entre el create y el join\n\n\n\n\nEsto es no pretende ser una receta, sino que una gu√≠a general"
  },
  {
    "objectID": "courses/4302.2.html#p1-quicksort-paralelo",
    "href": "courses/4302.2.html#p1-quicksort-paralelo",
    "title": "Auxiliar 2",
    "section": "P1 ‚Äî Quicksort paralelo",
    "text": "P1 ‚Äî Quicksort paralelo\nLa siguiente funci√≥n es una implementaci√≥n simple de quicksort:\n#include &lt;pthread.h&gt;\n\nvoid quicksort_seq(int a[], int i, int j) {\n    if (i &lt; j) {\n        int h = particionar(a, i, j);\n        quicksort_seq(a, i, h - 1);\n        quicksort_seq(a. h + 1, j);\n    }\n}\n\n\nConsidere particionar como la funci√≥n que selecciona el pivote y reordena el arreglo.\nLos valores menores al pivote quedan a la izquierda y los mayores a la derecha.\nSe le pide paralelizar la funci√≥n tal que haga uso de \\(N\\) cores:\nvoid quicksort(int a[], int i, int j, int n);\n\n\n\nIdea\nInvocaciones secuenciales independientes son directamente paralelizables"
  },
  {
    "objectID": "courses/4302.2.html#la-nueva-pesadilla",
    "href": "courses/4302.2.html#la-nueva-pesadilla",
    "title": "Auxiliar 2",
    "section": "La nueva pesadilla",
    "text": "La nueva pesadilla\n\nCuando se trabaja en paralelo, nacen nuevos enemigos.\n\n\nAl acceder a recursos compartidos desde varios procesos se pueden generar problemas como:\n\n\n\nDataraces\nVariables se sobreescriben\nRace conditions\nOrden incorrecto de ejecuci√≥n\nHambruna y Deadlocks\nUn procesos no obtiene tiempo de ejecuci√≥n"
  },
  {
    "objectID": "courses/4302.2.html#la-soluci√≥n",
    "href": "courses/4302.2.html#la-soluci√≥n",
    "title": "Auxiliar 2",
    "section": "La soluci√≥n",
    "text": "La soluci√≥n\n\n\nMutex\n\n\n\nMUTual EXclusi√≥n\n\n\nGarantiza la exclusi√≥n mutua, bloqueando el acceso a ‚Äúzonas cr√≠ticas‚Äù, las cuales son zonas del c√≥digo donde se manipulan los recursos compartidos.\n\n\n\n\nCondiciones\n\n\nHacen esperar a los procesos de manera eficiente hasta que se cumpla la condici√≥n para continuar la ejecuci√≥n."
  },
  {
    "objectID": "courses/4302.2.html#manejo",
    "href": "courses/4302.2.html#manejo",
    "title": "Auxiliar 2",
    "section": "Manejo",
    "text": "Manejo\nInicializaci√≥n\n\n\nUsando macros\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n\nDentro de una funci√≥n\npthread_mutex_t mutex;\n// ...\npthread_mutex_init(&mutex, NULL);\n\nUso\nPara solicitar el mutex:\nint pthread_mutex_lock(pthread_mutex_t *mutex); \nLa funci√≥n retorna solo para el primer proceso que pida el mutex, el resto queda esperando\nPara liberar el mutex:\nint pthread_mutex_unlock(pthread_mutex_t *mutex); \nAl liberar el mutex, todos los procesos se despiertan a la vez, no esta garantizado el orden de adquisici√≥n"
  },
  {
    "objectID": "courses/4302.2.html#comportamiento",
    "href": "courses/4302.2.html#comportamiento",
    "title": "Auxiliar 2",
    "section": "Comportamiento",
    "text": "Comportamiento\n\n\nUn mutex garantiza que s√≥lo un proceso pueda entrar a una su ‚Äúzona cr√≠tica‚Äù de c√≥digo.\nDebe ser solicitado para ingresar y liberado al salir.\nDos estados posibles:\n\n\n\nAbierto\nNing√∫n proceso ha solicitado el mutex\n\nCerrado\nAlg√∫n proceso ha solicitado el mutex y no ha sido liberado\n\n\nSi un proceso intenta solicitar un mutex cerrado, este ser√° suspendido hasta que el mutex sea liberado."
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-1",
    "href": "courses/4302.2.html#ejemplo-1",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\nint contador = 0;\nvoid aumentar_cont() {\n  contador++;\n}\n\nMala implementaci√≥n ü§¢\n\n\n\n¬øD√≥nde esta el error?\n\n\nHagamos un diagrama"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-2",
    "href": "courses/4302.2.html#ejemplo-2",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\npthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;\nint contador = 0;\nvoid aumentar_cont() {\n  pthread_mutex_lock(&m);\n  contador++;\n  pthread_mutex_unlock(&m);\n}\n\nBuena implementaci√≥n ü§†\n\n\n\nRepitamos el diagrama"
  },
  {
    "objectID": "courses/4302.2.html#motivaci√≥n",
    "href": "courses/4302.2.html#motivaci√≥n",
    "title": "Auxiliar 2",
    "section": "Motivaci√≥n",
    "text": "Motivaci√≥n\n\nUna forma de esperar podr√≠a ser:\nwhile (ocupado) {\n    ; // wait\n}\n\n\nEsto es mala idea porque mantiene ocupado al core\n\n\nEs mejor ‚Äúdormir‚Äù el proceso para desocupar el core"
  },
  {
    "objectID": "courses/4302.2.html#manejo-1",
    "href": "courses/4302.2.html#manejo-1",
    "title": "Auxiliar 2",
    "section": "Manejo",
    "text": "Manejo\nInicializaci√≥n\n\n\nUsando macros\npthread_cond_t mutex = PTHREAD_COND_INITIALIZER;\n\nDentro de una funci√≥n\npthread_cond_t cond;\n// ...\npthread_cond_init(&cond, NULL);\n\nUso\nPara hacer esperar a un proceso:\nint pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex); \nAl entrar en espera, el proceso liberar√° el mutex\nAl salir de espera, el proceso esperar√° el mutex y la funci√≥n retornar√° cuando lo obtenga\nPara despertar procesos:\nint pthread_cond_broadcast(pthread_cond_t *cond); // despertar a todos\nint pthread_cond_signal(pthread_cond_t *cond); // despertar uno (cualquiera)"
  },
  {
    "objectID": "courses/4302.2.html#comportamiento-1",
    "href": "courses/4302.2.html#comportamiento-1",
    "title": "Auxiliar 2",
    "section": "Comportamiento",
    "text": "Comportamiento\n\n\nLa espera es eficiente, dejando disponible el core.\nLa funci√≥n wait se hace cargo de liberar y pedir el mutex asociado.\nLa funci√≥n broadcast despierta a todos los procesos en espera.\nLa funci√≥n signal despierta a solo sin orden garantizado.\nUn proceso que esperaba por una condici√≥n puede quedar en espera por un mutex."
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-3",
    "href": "courses/4302.2.html#ejemplo-3",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    while(contador &lt; 10) {;}\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg√≥ a 10\");\n    return 0;\n}\n\nMala implementaci√≥n ü§¢"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-4",
    "href": "courses/4302.2.html#ejemplo-4",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    while(contador &lt; 10) {;}\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg√≥ a 10\");\n    return 0;\n}\nBusy waiting"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-5",
    "href": "courses/4302.2.html#ejemplo-5",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    while(contador &lt; 10) {;}\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg√≥ a 10\");\n    return 0;\n}\nHambruna\n\n\nToma el mutex y no lo libera antes de esperar\nNo es Deadlock porque el primer proceso est√° despierto"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-6",
    "href": "courses/4302.2.html#ejemplo-6",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    if(contador == 10){\n        pthread_cond_broadcast(&cond);\n    }\n    while(contador &lt; 10){\n        pthread_cond_wait(&cond, &mutex);\n    }\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg√≥ a 10\");\n    return 0; \n}\n\nBuena implementaci√≥n ü§†"
  },
  {
    "objectID": "courses/4302.2.html#p2-colecta",
    "href": "courses/4302.2.html#p2-colecta",
    "title": "Auxiliar 2",
    "section": "P2 ‚Äî Colecta",
    "text": "P2 ‚Äî Colecta\nSe necesita crear un sistemas para juntar exactamente una cantidad \\(X\\) de dinero:\n\n\nDefinir el tipo de datos Colecta.\nProgramar la funci√≥n\nColecta *nuevaColecta(double meta);\nQue crea y retorna una colecta para juntar meta pesos.\nProgramar la funci√≥n\ndouble aportar(Colecta *c, double monto);\nQue es invocada desde m√∫ltiples procesos para contribuir monto pesos. El valor de retorno de la funci√≥n es el m√≠nimo entre monto y lo que falta para llegar a la meta.\nLa funci√≥n retornar una vez que la meta se cumpla"
  },
  {
    "objectID": "courses/index.html",
    "href": "courses/index.html",
    "title": "Cursos",
    "section": "",
    "text": "Aqu√≠ esta el material de cursos que he dictado",
    "crumbs": [
      "Cursos",
      "2024"
    ]
  }
]