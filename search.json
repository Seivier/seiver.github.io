[
  {
    "objectID": "courses/4302.1.html#su-auxiliar",
    "href": "courses/4302.1.html#su-auxiliar",
    "title": "Auxiliar 1",
    "section": "Su auxiliar",
    "text": "Su auxiliar"
  },
  {
    "objectID": "courses/4302.1.html#su-auxiliar-1",
    "href": "courses/4302.1.html#su-auxiliar-1",
    "title": "Auxiliar 1",
    "section": "Su auxiliar",
    "text": "Su auxiliar\n\n\n\n\n\nVicente Gonz√°lez\nAuxiliar de\n\nPSS\nComputaci√≥n en GPU\nSistemas Operativos\nMetodolog√≠as de Dise√±o y Programaci√≥n\n\nSiempre disponible en persona üòÉ\nLento para responder correos üòü\nDoble titulaci√≥n\nNo duden en preguntar"
  },
  {
    "objectID": "courses/4302.1.html#section",
    "href": "courses/4302.1.html#section",
    "title": "Auxiliar 1",
    "section": "",
    "text": "Procesos Pesados\n\n\n\nFork\nNo comparten memoria\nCostosos de instanciar\nSeguros\n\n\n\n\nProcesos livianos\n\n\n\nPthreads\nComparten memoria\nBaratos de instanciar\nDatarraces"
  },
  {
    "objectID": "courses/4302.1.html#creaci√≥n-de-threads",
    "href": "courses/4302.1.html#creaci√≥n-de-threads",
    "title": "Auxiliar 1",
    "section": "Creaci√≥n de threads",
    "text": "Creaci√≥n de threads\nint pthread_create(pthread_t *thread, \n                   const pthread_attr_t *attr, \n                   void *(*start_routine)(void *), \n                   void *arg);\n\nCompuesto por:"
  },
  {
    "objectID": "courses/4302.1.html#creaci√≥n-de-threads-1",
    "href": "courses/4302.1.html#creaci√≥n-de-threads-1",
    "title": "Auxiliar 1",
    "section": "Creaci√≥n de threads",
    "text": "Creaci√≥n de threads\nint pthread_create(pthread_t *thread, \n                   const pthread_attr_t *attr, \n                   void *(*start_routine)(void *), \n                   void *arg);\nCompuesto por:\n\nLa referencia al proceso"
  },
  {
    "objectID": "courses/4302.1.html#creaci√≥n-de-threads-2",
    "href": "courses/4302.1.html#creaci√≥n-de-threads-2",
    "title": "Auxiliar 1",
    "section": "Creaci√≥n de threads",
    "text": "Creaci√≥n de threads\nint pthread_create(pthread_t *thread, \n                   const pthread_attr_t *attr, \n                   void *(*start_routine)(void *), \n                   void *arg);\nCompuesto por:\n\nLa referencia al proceso\nAtributos especiales del proceso (NULL)"
  },
  {
    "objectID": "courses/4302.1.html#creaci√≥n-de-threads-3",
    "href": "courses/4302.1.html#creaci√≥n-de-threads-3",
    "title": "Auxiliar 1",
    "section": "Creaci√≥n de threads",
    "text": "Creaci√≥n de threads\nint pthread_create(pthread_t *thread, \n                   const pthread_attr_t *attr, \n                   void *(*start_routine)(void *), \n                   void *arg);\nCompuesto por:\n\nLa referencia al proceso\nAtributos especiales del proceso (NULL)\nLa rutina a ejecutar por el proceso"
  },
  {
    "objectID": "courses/4302.1.html#creaci√≥n-de-threads-4",
    "href": "courses/4302.1.html#creaci√≥n-de-threads-4",
    "title": "Auxiliar 1",
    "section": "Creaci√≥n de threads",
    "text": "Creaci√≥n de threads\nint pthread_create(pthread_t *thread, \n                   const pthread_attr_t *attr, \n                   void *(*start_routine)(void *), \n                   void *arg);\nCompuesto por:\n\nLa referencia al proceso\nAtributos especiales del proceso (NULL)\nLa rutina a ejecutar por el proceso\nLos argumentos a pasar a la rutina"
  },
  {
    "objectID": "courses/4302.1.html#creaci√≥n-de-threads-5",
    "href": "courses/4302.1.html#creaci√≥n-de-threads-5",
    "title": "Auxiliar 1",
    "section": "Creaci√≥n de threads",
    "text": "Creaci√≥n de threads\nint pthread_create(pthread_t *thread, \n                   const pthread_attr_t *attr, \n                   void *(*start_routine)(void *), \n                   void *arg);\n\n\nRetorna 0 si la creaci√≥n fue exitosa\nEl thread termina cuando start_routine termina\nTodo thread creado debe ser enterrado con\nint pthread_join(pthread_t thread, void **return_value);\nLos thread no enterrados se convierte en zombies y no devuelven los recursos\nLa funci√≥n pthread_join espera a que el thread termine"
  },
  {
    "objectID": "courses/4302.1.html#ejemplo",
    "href": "courses/4302.1.html#ejemplo",
    "title": "Auxiliar 1",
    "section": "Ejemplo",
    "text": "Ejemplo\n#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n\nvoid *thread(void *ptr) {\n  char* nombre = (char*) ptr; // Castear argumento\n  printf(\"Thread - %s\\n\", nombre); // Trabajo en paralelo\n  return NULL; // Retorno\n}\n\nint main() {\n  pthread_t pid_1, pid_2; // Guardar PID de los threads lanzados\n  char* nombre_1 = \"primero\";\n  char* nombre_2 = \"segundo\";\n  pthread_create(&pid_1, NULL, thread, nombre_1); // lanzar thread1\n  pthread_create(&pid_2, NULL, thread, nombre_2); // lanzar thread2\n  pthread_join(pid_1, NULL); // esperar thread 1\n  pthread_join(pid_2, NULL); // esperar thread 2\n  return 0;\n}\n\n¬øC√≥mo puedo usar m√°s argumentos?\n\n\nUsamos una estructura!"
  },
  {
    "objectID": "courses/4302.1.html#ejemplo-1",
    "href": "courses/4302.1.html#ejemplo-1",
    "title": "Auxiliar 1",
    "section": "Ejemplo",
    "text": "Ejemplo\n#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n\ntypedef struct {\n  char* name;\n  int age;\n} Args;\n\nvoid *thread(void *ptr) {\n  char* nombre = (char*) ptr; // Castear argumento\n  printf(\"Thread - %s\\n\", nombre); // Trabajo en paralelo\n  return NULL; // Retorno\n}\n\nint main() {\n  pthread_t pid_1, pid_2; // Guardar PID de los threads lanzados\n  char* nombre_1 = \"primero\";\n  char* nombre_2 = \"segundo\";\n  pthread_create(&pid_1, NULL, thread, nombre_1); // lanzar thread1\n  pthread_create(&pid_2, NULL, thread, nombre_2); // lanzar thread2\n  pthread_join(pid_1, NULL); // esperar thread 1\n  pthread_join(pid_2, NULL); // esperar thread 2\n  return 0;\n}"
  },
  {
    "objectID": "courses/4302.1.html#ejemplo-2",
    "href": "courses/4302.1.html#ejemplo-2",
    "title": "Auxiliar 1",
    "section": "Ejemplo",
    "text": "Ejemplo\n#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n\ntypedef struct {\n  char* name;\n  int age;\n} Args;\n\nvoid *thread(void *ptr) {\n  char* nombre = (char*) ptr; // Castear argumento\n  printf(\"Thread - %s\\n\", nombre); // Trabajo en paralelo\n  return NULL; // Retorno\n}\n\nint main() {\n  pthread_t pid_1, pid_2; // Guardar PID de los threads lanzados\n  Args a1 = {\"primero\", 10} // inicializamos los args de t1\n  Args a2 = {\"segundo\", 20} // inicializamos los args de t2\n  pthread_create(&pid_1, NULL, thread, &a1); // la pasamos por referencia\n  pthread_create(&pid_2, NULL, thread, &a2); // la pasamos por referencia\n  pthread_join(pid_1, NULL); // esperar thread 1\n  pthread_join(pid_2, NULL); // esperar thread 2\n  return 0;\n}"
  },
  {
    "objectID": "courses/4302.1.html#ejemplo-3",
    "href": "courses/4302.1.html#ejemplo-3",
    "title": "Auxiliar 1",
    "section": "Ejemplo",
    "text": "Ejemplo\n#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n\ntypedef struct {\n  char* name;\n  int age;\n} Args;\n\nvoid *thread(void *ptr) {\n  Args* a = (Args*) ptr; // Castear a la estructura\n  printf(\"Thread - %s (%d)\\n\", a-&gt;name, a-&gt;age); // Accedemos a los miembros con -&gt;\n  return NULL; // Retorno\n}\n\nint main() {\n  pthread_t pid_1, pid_2; // Guardar PID de los threads lanzados\n  Args a1 = {\"primero\", 10} // inicializamos los args de t1\n  Args a2 = {\"segundo\", 20} // inicializamos los args de t2\n  pthread_create(&pid_1, NULL, thread, &a1); // la pasamos por referencia\n  pthread_create(&pid_2, NULL, thread, &a2); // la pasamos por referencia\n  pthread_join(pid_1, NULL); // esperar thread 1\n  pthread_join(pid_2, NULL); // esperar thread 2\n  return 0;\n}"
  },
  {
    "objectID": "courses/4302.1.html#how-to",
    "href": "courses/4302.1.html#how-to",
    "title": "Auxiliar 1",
    "section": "How to?",
    "text": "How to?\nDise√±o\n\n\nEncontrar las partes paralelizables\nCrear la estructura que permita ingresar los argumentos necesarios\nProgramar la rutina\n\n\n\n\nA veces la rutina s√≥lo ajusta los argumentos para llamar a otra funci√≥n\nEn la estructura de los argumentos podemos guardar cualquier cosa\n\n\nEsto es no pretende ser una receta, sino que una gu√≠a general"
  },
  {
    "objectID": "courses/4302.1.html#how-to-1",
    "href": "courses/4302.1.html#how-to-1",
    "title": "Auxiliar 1",
    "section": "How to?",
    "text": "How to?\nL√≥gica\n\n\nLanzar los threads con sus argumentos correspondientes\nSi aplica, realizar trabajo en el thread principal\nEsperar a que el trabajo paralelizado termine\nEnterrar los resultados y recolectar los resultados\n\n\n\n\nAntes del join no existe garant√≠a de que el trabajo se haya terminado\nAseg√∫rese de que exista paralelismo entre el create y el join\n\n\nEsto es no pretende ser una receta, sino que una gu√≠a general"
  },
  {
    "objectID": "courses/4302.1.html#p1-buscar-factor",
    "href": "courses/4302.1.html#p1-buscar-factor",
    "title": "Auxiliar 1",
    "section": "P1 ‚Äî Buscar Factor",
    "text": "P1 ‚Äî Buscar Factor\n\nParalelicemos esta funci√≥n que busca cualquier factor de un n√∫mero para acelerarla utilizando \\(P\\) cores\n\n\n#include &lt;pthread.h&gt;\n\ntypedef unsigned long long ulonglong;\ntypedef unsigned int uint;\n\n// busca un factor del n√∫mero entero x en el rango [i, j]\nuint buscarFactor(ulonglong x, uint i, uint j){\n    for (uint k = i; k &lt;= j; k++){\n        if (x % k == 0)\n            return k;\n    }\n    return 0;\n}\n\n\nDesaf√≠o: Lanzar \\(P-1\\) procesos y utilizar el principal en la b√∫squeda"
  },
  {
    "objectID": "courses/4302.1.html#p1-buscar-factor-1",
    "href": "courses/4302.1.html#p1-buscar-factor-1",
    "title": "Auxiliar 1",
    "section": "P1 ‚Äî Buscar Factor",
    "text": "P1 ‚Äî Buscar Factor\nPropuesto\n¬øC√≥mo har√≠as para que todos los procesos terminen cuando se encuentre el primer factor?\n#include &lt;pthread.h&gt;\n\ntypedef unsigned long long ulonglong;\ntypedef unsigned int uint;\n\n// busca un factor del n√∫mero entero x en el rango [i, j]\nuint buscarFactor(ulonglong x, uint i, uint j){\n    for (uint k = i; k &lt;= j; k++){\n        if (x % k == 0)\n            return k;\n    }\n    return 0;\n}\n\nHint: Quiz√°s una variable global ayudar√≠a"
  },
  {
    "objectID": "courses/4302.7.html#mensajes",
    "href": "courses/4302.7.html#mensajes",
    "title": "Auxiliar 7",
    "section": "Mensajes",
    "text": "Mensajes\n\n\n\n\n\n\nnSend(th, *msg);\n\n\n\n\n\n\n\n\nnReceive(*pth, timeout_ms);"
  },
  {
    "objectID": "courses/4302.7.html#how-to",
    "href": "courses/4302.7.html#how-to",
    "title": "Auxiliar 7",
    "section": "How to?",
    "text": "How to?\n\n\n\nint nSend(nThread th, void *msg);\n\n\nEnv√≠a un mensaje msg al thread th.\nSuspende al thread hasta que se reciba una respuesta desde th.\nRetorna el valor recibido.\n\n\n\n\nint nReply(nThread th, int rc);\n\n\nEnv√≠a una respuesta con rc a un mensaje recibido de th.\nNo suspende al thread.\n\n\n\n\n\nvoid* nReceive(nThread *pth, int timeout_ms);\n\n\nSuspende al thread hasta recibir un mensaje.\nEl emisor del mensaje se guarda en pth.\nRetorna el mensaje recibido.\nLa suspensi√≥n dura timeout_ms.\nSi no se recibe mensaje se retorna de todas formas.\nSi timeout_ms \\(&lt; 0\\) entonces la suspensi√≥n es infinita."
  },
  {
    "objectID": "courses/4302.7.html#impresora-compartida",
    "href": "courses/4302.7.html#impresora-compartida",
    "title": "Auxiliar 7",
    "section": "Impresora compartida",
    "text": "Impresora compartida\n\n\nPatron Request\nvoid obtenerImpresora(){\n  pthread_mutex_lock(&m);\n  Request req = {FALSE, \n                 PTHREAD_COND_INITIALIZER};\n  put(q, &req);\n  pthread_cond_signal(&obtener);\n  while (!req.ready){\n    pthread_cond_wait(&req.w, &m);\n  }\n  pthread_mutex_unlock(&m);\n}\n\nvoid devolverImpresora(){\n  pthread_mutex_lock(&m);\n  ocupada = FALSE;\n  pthread_cond_signal(&devolver);\n  pthread_mutex_unlock(&m);\n}\n\n‚ú®Mensajes‚ú®\nenum Mensaje {OBTENER, DEVOLVER};\n\nvoid obtenerImpresora(){\n  int msg = OBTENER;\n  // Bloquear thread hasta recibir respuesta\n  nSend(impresora, &msg);\n}\nvoid devolverImpresora(){\n  int msg = DEVOLVER;\n  nSend(impresora, &msg);\n}"
  },
  {
    "objectID": "courses/4302.7.html#impresora-compartida-1",
    "href": "courses/4302.7.html#impresora-compartida-1",
    "title": "Auxiliar 7",
    "section": "Impresora compartida",
    "text": "Impresora compartida\nPatron Request\nvoid ImpresoraServer() {\n  while(TRUE) {\n    pthread_mutex_lock(&m);\n    if(emptyQueue(q)) {\n      struct timespec ts;\n      clock_gettime(CLOCK_REALTIME, &ts);\n      ts.tv_sec += 60*5;\n      while(emptyQueue(q) && pthread_cond_timed_wait(&obtener, &m, &ts) != ETIMEDOUT) {\n        ;//wait por 5 mins\n      }\n\n      if(emptyQueue(q)) {\n        modoBajoConsumo();\n        while (emptyQueue(q)) {\n          pthread_cond_wait(&obtener, &m);\n        }\n        modoUsoNormal();\n      }\n    }\n\n    if(!emptyQueue(q)) {\n      Request *req = get(q);\n      req -&gt; ready = TRUE;\n      ocupada = TRUE;\n      pthread_cond_signal(&req-&gt;w);\n    }\n\n    while(ocupada){\n      pthread_cond_wait(&devolver, &m);\n    }\n    pthread_mutex_unlock(&m);\n  }\n}"
  },
  {
    "objectID": "courses/4302.7.html#impresora-compartida-2",
    "href": "courses/4302.7.html#impresora-compartida-2",
    "title": "Auxiliar 7",
    "section": "Impresora compartida",
    "text": "Impresora compartida\n‚ú®Mensajes‚ú®\nint ImpresoraServer() {\n  Queue *q = makeQueue();\n  int ocupado = FALSE;\n  nThread t;\n  int *msg;\n  while (TRUE) {\n    // Si no esta ocupada, esperar\n    if (!ocupado) {\n      // esperar 5 minutos (5min * 60s * 1000ms)\n      msg = (int *) nReceive(&t, 60 * 5 * 1000);\n      if (t == NULL) {\n        modoBajoConsumo();\n        msg = (int*) nRecieve(&t,\n        -1); // esperar\n        modoUsoNormal();\n      }\n    } else { // Esperar a que se desocupe impresora\n      msg = (int*) nReceive(&t, -1); // esperar\n      if (*msg == OBTENER) {\n        // Encolar si esta ocupada,\n        if (ocupado)\n          put(q,t);\n        else { // responder si esta disponible\n          ocupado = TRUE;\n          nReply(t,0);\n        }\n      } else if (*msg == DEVOLVER) {\n        nReply(t, 0); // ‚Äúok, la devolviste‚Äù\n        if (EmptyFifoQueue(q)) {\n          ocupado = FALSE;\n        } else {\n          // Entregar impresora a siguiente thread\n          nThread *t2 = (nThread*) get(q);\n          nReply(t2, 0);\n        }\n      }\n    }\n  }\n}"
  },
  {
    "objectID": "courses/4302.7.html#so-far-so-good",
    "href": "courses/4302.7.html#so-far-so-good",
    "title": "Auxiliar 7",
    "section": "So far so good",
    "text": "So far so good"
  },
  {
    "objectID": "courses/4302.7.html#p1-timeouts",
    "href": "courses/4302.7.html#p1-timeouts",
    "title": "Auxiliar 7",
    "section": "P1 ‚Äì Timeouts",
    "text": "P1 ‚Äì Timeouts\nImplemente:\nint nSend(nThread th, void *msg)\n\nvoid *nReceive(nThread *pth, int timeout_ms)\n\nvoid nReply(nThread th, int rc)\nEsta vez con timeouts!!"
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\nUn scheduler debe:\n\nActivar procesos suspendidos\nSuspender procesos activos\nSaber cual es el siguiente proceso que debe activarse\n\nLo llamamos cuando usamos setReady(), suspend() o schedule().\nVeamos como se implementan con prioridades"
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-1",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-1",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\n#include \"nthread-impl.h\"\n\nstatic NthQueue *nth_pri1ReadyQueue[MAXPRI];\n\nvoid nSetPriority(nThread th, int pri) {\n  START_CRITICAL\n  \n  th-&gt;pri= pri;\n  schedule(); \n  \n  END_CRITICAL\n}\n\nstatic void nth_pri1SetReady(nThread th) {\n  CHECK_CRITICAL(\"nth_fcfsSetReady\")\n  \n  if (th-&gt;status==READY || th-&gt;status==RUN)\n    nFatalError(\"nth_fcfsReady\",\n                \"The thread was already in READY status\\n\");\n\n  th-&gt;status= READY;\n  nth_putBack(nth_pri1ReadyQueue[th-&gt;pri], th);\n}\n\nstatic void nth_pri1Suspend(State waitState) {\n  CHECK_CRITICAL(\"nth_fcfsSuspend\")\n  \n  nThread th= nSelf();\n  if (th-&gt;status!=RUN && th-&gt;status!=READY)\n    nFatalError(\"nth_fcfsSuspend\", \n                \"Thread was not ready or run\\n\");\n  th-&gt;status= waitState;\n}"
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-2",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-2",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\n#include \"nthread-impl.h\"\n\nstatic NthQueue *nth_pri1ReadyQueue[MAXPRI];\n\nvoid nSetPriority(nThread th, int pri) {\n  START_CRITICAL\n  \n  th-&gt;pri= pri;\n  schedule(); \n  \n  END_CRITICAL\n}\n\nstatic void nth_pri1SetReady(nThread th) {\n  CHECK_CRITICAL(\"nth_fcfsSetReady\")\n  \n  if (th-&gt;status==READY || th-&gt;status==RUN)\n    nFatalError(\"nth_fcfsReady\",\n                \"The thread was already in READY status\\n\");\n\n  th-&gt;status= READY;\n  nth_putBack(nth_pri1ReadyQueue[th-&gt;pri], th);\n}\n\nstatic void nth_pri1Suspend(State waitState) {\n  CHECK_CRITICAL(\"nth_fcfsSuspend\")\n  \n  nThread th= nSelf();\n  if (th-&gt;status!=RUN && th-&gt;status!=READY)\n    nFatalError(\"nth_fcfsSuspend\", \n                \"Thread was not ready or run\\n\");\n  th-&gt;status= waitState;\n}\n\n\n\nManejaremos la prioridad con un arreglo de colas FIFO"
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-3",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-3",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\n#include \"nthread-impl.h\"\n\nstatic NthQueue *nth_pri1ReadyQueue[MAXPRI];\n\nvoid nSetPriority(nThread th, int pri) {\n  START_CRITICAL\n  \n  th-&gt;pri= pri;\n  schedule(); \n  \n  END_CRITICAL\n}\n\nstatic void nth_pri1SetReady(nThread th) {\n  CHECK_CRITICAL(\"nth_fcfsSetReady\")\n  \n  if (th-&gt;status==READY || th-&gt;status==RUN)\n    nFatalError(\"nth_fcfsReady\",\n                \"The thread was already in READY status\\n\");\n\n  th-&gt;status= READY;\n  nth_putBack(nth_pri1ReadyQueue[th-&gt;pri], th);\n}\n\nstatic void nth_pri1Suspend(State waitState) {\n  CHECK_CRITICAL(\"nth_fcfsSuspend\")\n  \n  nThread th= nSelf();\n  if (th-&gt;status!=RUN && th-&gt;status!=READY)\n    nFatalError(\"nth_fcfsSuspend\", \n                \"Thread was not ready or run\\n\");\n  th-&gt;status= waitState;\n}\n\n\n\nManejaremos la prioridad con un arreglo de colas FIFO\nGuardamos la prioridad en el descriptor del thread"
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-4",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-4",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\n#include \"nthread-impl.h\"\n\nstatic NthQueue *nth_pri1ReadyQueue[MAXPRI];\n\nvoid nSetPriority(nThread th, int pri) {\n  START_CRITICAL\n  \n  th-&gt;pri= pri;\n  schedule(); \n  \n  END_CRITICAL\n}\n\nstatic void nth_pri1SetReady(nThread th) {\n  CHECK_CRITICAL(\"nth_fcfsSetReady\")\n  \n  if (th-&gt;status==READY || th-&gt;status==RUN)\n    nFatalError(\"nth_fcfsReady\",\n                \"The thread was already in READY status\\n\");\n\n  th-&gt;status= READY;\n  nth_putBack(nth_pri1ReadyQueue[th-&gt;pri], th);\n}\n\nstatic void nth_pri1Suspend(State waitState) {\n  CHECK_CRITICAL(\"nth_fcfsSuspend\")\n  \n  nThread th= nSelf();\n  if (th-&gt;status!=RUN && th-&gt;status!=READY)\n    nFatalError(\"nth_fcfsSuspend\", \n                \"Thread was not ready or run\\n\");\n  th-&gt;status= waitState;\n}\n\n\n\nManejaremos la prioridad con un arreglo de colas FIFO\nGuardamos la prioridad en el descriptor del thread\nAl cambiar la prioridad puede resultar en que el thread actual ya no sea de mejor prioridad"
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-5",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-5",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\n#include \"nthread-impl.h\"\n\nstatic NthQueue *nth_pri1ReadyQueue[MAXPRI];\n\nvoid nSetPriority(nThread th, int pri) {\n  START_CRITICAL\n  \n  th-&gt;pri= pri;\n  schedule(); \n  \n  END_CRITICAL\n}\n\nstatic void nth_pri1SetReady(nThread th) {\n  CHECK_CRITICAL(\"nth_fcfsSetReady\")\n  \n  if (th-&gt;status==READY || th-&gt;status==RUN)\n    nFatalError(\"nth_fcfsReady\",\n                \"The thread was already in READY status\\n\");\n\n  th-&gt;status= READY;\n  nth_putBack(nth_pri1ReadyQueue[th-&gt;pri], th);\n}\n\nstatic void nth_pri1Suspend(State waitState) {\n  CHECK_CRITICAL(\"nth_fcfsSuspend\")\n  \n  nThread th= nSelf();\n  if (th-&gt;status!=RUN && th-&gt;status!=READY)\n    nFatalError(\"nth_fcfsSuspend\", \n                \"Thread was not ready or run\\n\");\n  th-&gt;status= waitState;\n}\n\n\n\nManejaremos la prioridad con un arreglo de colas FIFO\nGuardamos la prioridad en el descriptor del thread\nAl cambiar la prioridad puede resultar en que el thread actual ya no sea de mejor prioridad\nCuando un thread este listo, entonces lo guardamos en su cola respectiva."
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-6",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-6",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\n#include \"nthread-impl.h\"\n\nstatic NthQueue *nth_pri1ReadyQueue[MAXPRI];\n\nvoid nSetPriority(nThread th, int pri) {\n  START_CRITICAL\n  \n  th-&gt;pri= pri;\n  schedule(); \n  \n  END_CRITICAL\n}\n\nstatic void nth_pri1SetReady(nThread th) {\n  CHECK_CRITICAL(\"nth_fcfsSetReady\")\n  \n  if (th-&gt;status==READY || th-&gt;status==RUN)\n    nFatalError(\"nth_fcfsReady\",\n                \"The thread was already in READY status\\n\");\n\n  th-&gt;status= READY;\n  nth_putBack(nth_pri1ReadyQueue[th-&gt;pri], th);\n}\n\nstatic void nth_pri1Suspend(State waitState) {\n  CHECK_CRITICAL(\"nth_fcfsSuspend\")\n  \n  nThread th= nSelf();\n  if (th-&gt;status!=RUN && th-&gt;status!=READY)\n    nFatalError(\"nth_fcfsSuspend\", \n                \"Thread was not ready or run\\n\");\n  th-&gt;status= waitState;\n}\n\n\n\nManejaremos la prioridad con un arreglo de colas FIFO\nGuardamos la prioridad en el descriptor del thread\nAl cambiar la prioridad puede resultar en que el thread actual ya no sea de mejor prioridad\nCuando un thread este listo, entonces lo guardamos en su cola respectiva.\nCuando se tenga que suspender, solo hay que cambiar el estado a WAIT (u otro que sea necesario)"
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-7",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-7",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Schedule(void) {\n  CHECK_CRITICAL(\"nth_fcfsSchedule\")\n  \n  nThread thisTh= nSelf();\n  if (thisTh!=NULL && (thisTh-&gt;status==READY || thisTh-&gt;status==RUN)) {\n    thisTh-&gt;status= READY;\n    nth_putBack(nth_pri1ReadyQueue[thisTh-&gt;pri], thisTh);\n  }\n  nThread nextTh= NULL;\n  while (nextTh==NULL) {\n    int i=0;\n    while (i&lt;MAXPRI) {\n      if (!nth_emptyQueue(nth_pri1ReadyQueue[i]))\n        break;\n      i++;\n    }\n    if (i&lt;MAXPRI) {\n      nextTh= nth_getFront(nth_pri1ReadyQueue[i]);\n      break;\n    }\n    else {\n      nth_coreIsIdle[0]= 1; \n      sigsuspend(&nth_sigsetApp);\n      nth_coreIsIdle[0]= 0;\n    }\n  }\n  \n  nth_changeContext(thisTh, nextTh);\n\n  nth_setSelf(thisTh); \n  \n  thisTh-&gt;status= RUN;\n}"
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-8",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-8",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Schedule(void) {\n  CHECK_CRITICAL(\"nth_fcfsSchedule\")\n  \n  nThread thisTh= nSelf();\n  if (thisTh!=NULL && (thisTh-&gt;status==READY || thisTh-&gt;status==RUN)) {\n    thisTh-&gt;status= READY;\n    nth_putBack(nth_pri1ReadyQueue[thisTh-&gt;pri], thisTh);\n  }\n  nThread nextTh= NULL;\n  while (nextTh==NULL) {\n    int i=0;\n    while (i&lt;MAXPRI) {\n      if (!nth_emptyQueue(nth_pri1ReadyQueue[i]))\n        break;\n      i++;\n    }\n    if (i&lt;MAXPRI) {\n      nextTh= nth_getFront(nth_pri1ReadyQueue[i]);\n      break;\n    }\n    else {\n      nth_coreIsIdle[0]= 1; \n      sigsuspend(&nth_sigsetApp);\n      nth_coreIsIdle[0]= 0;\n    }\n  }\n  \n  nth_changeContext(thisTh, nextTh);\n\n  nth_setSelf(thisTh); \n  \n  thisTh-&gt;status= RUN;\n}\n\n\n\nAl llamar a schedule() buscamos suspender el thread para darle el core al que tenga mejor prioridad."
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-9",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-9",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Schedule(void) {\n  CHECK_CRITICAL(\"nth_fcfsSchedule\")\n  \n  nThread thisTh= nSelf();\n  if (thisTh!=NULL && (thisTh-&gt;status==READY || thisTh-&gt;status==RUN)) {\n    thisTh-&gt;status= READY;\n    nth_putBack(nth_pri1ReadyQueue[thisTh-&gt;pri], thisTh);\n  }\n  nThread nextTh= NULL;\n  while (nextTh==NULL) {\n    int i=0;\n    while (i&lt;MAXPRI) {\n      if (!nth_emptyQueue(nth_pri1ReadyQueue[i]))\n        break;\n      i++;\n    }\n    if (i&lt;MAXPRI) {\n      nextTh= nth_getFront(nth_pri1ReadyQueue[i]);\n      break;\n    }\n    else {\n      nth_coreIsIdle[0]= 1; \n      sigsuspend(&nth_sigsetApp);\n      nth_coreIsIdle[0]= 0;\n    }\n  }\n  \n  nth_changeContext(thisTh, nextTh);\n\n  nth_setSelf(thisTh); \n  \n  thisTh-&gt;status= RUN;\n}\n\n\n\nAl llamar a schedule() buscamos suspender el thread para darle el core al que tenga mejor prioridad.\nSi el thread no esta suspendido (WAIT) se reincorpora a las colas de prioridades."
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-10",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-10",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Schedule(void) {\n  CHECK_CRITICAL(\"nth_fcfsSchedule\")\n  \n  nThread thisTh= nSelf();\n  if (thisTh!=NULL && (thisTh-&gt;status==READY || thisTh-&gt;status==RUN)) {\n    thisTh-&gt;status= READY;\n    nth_putBack(nth_pri1ReadyQueue[thisTh-&gt;pri], thisTh);\n  }\n  nThread nextTh= NULL;\n  while (nextTh==NULL) {\n    int i=0;\n    while (i&lt;MAXPRI) {\n      if (!nth_emptyQueue(nth_pri1ReadyQueue[i]))\n        break;\n      i++;\n    }\n    if (i&lt;MAXPRI) {\n      nextTh= nth_getFront(nth_pri1ReadyQueue[i]);\n      break;\n    }\n    else {\n      nth_coreIsIdle[0]= 1; \n      sigsuspend(&nth_sigsetApp);\n      nth_coreIsIdle[0]= 0;\n    }\n  }\n  \n  nth_changeContext(thisTh, nextTh);\n\n  nth_setSelf(thisTh); \n  \n  thisTh-&gt;status= RUN;\n}\n\n\n\nAl llamar a schedule() buscamos suspender el thread para darle el core al que tenga mejor prioridad.\nSi el thread no esta suspendido (WAIT) se reincorpora a las colas de prioridades.\nSe debe mantener schedule() hasta obtener el siguiente thread."
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-11",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-11",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Schedule(void) {\n  CHECK_CRITICAL(\"nth_fcfsSchedule\")\n  \n  nThread thisTh= nSelf();\n  if (thisTh!=NULL && (thisTh-&gt;status==READY || thisTh-&gt;status==RUN)) {\n    thisTh-&gt;status= READY;\n    nth_putBack(nth_pri1ReadyQueue[thisTh-&gt;pri], thisTh);\n  }\n  nThread nextTh= NULL;\n  while (nextTh==NULL) {\n    int i=0;\n    while (i&lt;MAXPRI) {\n      if (!nth_emptyQueue(nth_pri1ReadyQueue[i]))\n        break;\n      i++;\n    }\n    if (i&lt;MAXPRI) {\n      nextTh= nth_getFront(nth_pri1ReadyQueue[i]);\n      break;\n    }\n    else {\n      nth_coreIsIdle[0]= 1; \n      sigsuspend(&nth_sigsetApp);\n      nth_coreIsIdle[0]= 0;\n    }\n  }\n  \n  nth_changeContext(thisTh, nextTh);\n\n  nth_setSelf(thisTh); \n  \n  thisTh-&gt;status= RUN;\n}\n\n\n\nAl llamar a schedule() buscamos suspender el thread para darle el core al que tenga mejor prioridad.\nSi el thread no esta suspendido (WAIT) se reincorpora a las colas de prioridades.\nSe debe mantener schedule() hasta obtener el siguiente thread.\nBuscamos la cola con mejor prioridad."
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-12",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-12",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Schedule(void) {\n  CHECK_CRITICAL(\"nth_fcfsSchedule\")\n  \n  nThread thisTh= nSelf();\n  if (thisTh!=NULL && (thisTh-&gt;status==READY || thisTh-&gt;status==RUN)) {\n    thisTh-&gt;status= READY;\n    nth_putBack(nth_pri1ReadyQueue[thisTh-&gt;pri], thisTh);\n  }\n  nThread nextTh= NULL;\n  while (nextTh==NULL) {\n    int i=0;\n    while (i&lt;MAXPRI) {\n      if (!nth_emptyQueue(nth_pri1ReadyQueue[i]))\n        break;\n      i++;\n    }\n    if (i&lt;MAXPRI) {\n      nextTh= nth_getFront(nth_pri1ReadyQueue[i]);\n      break;\n    }\n    else {\n      nth_coreIsIdle[0]= 1; \n      sigsuspend(&nth_sigsetApp);\n      nth_coreIsIdle[0]= 0;\n    }\n  }\n  \n  nth_changeContext(thisTh, nextTh);\n\n  nth_setSelf(thisTh); \n  \n  thisTh-&gt;status= RUN;\n}\n\n\n\nAl llamar a schedule() buscamos suspender el thread para darle el core al que tenga mejor prioridad.\nSi el thread no esta suspendido (WAIT) se reincorpora a las colas de prioridades.\nSe debe mantener schedule() hasta obtener el siguiente thread.\nBuscamos la cola con mejor prioridad.\nSi encontramos dicha cola, obtenemos el primer thread en esta."
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-13",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-13",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Schedule(void) {\n  CHECK_CRITICAL(\"nth_fcfsSchedule\")\n  \n  nThread thisTh= nSelf();\n  if (thisTh!=NULL && (thisTh-&gt;status==READY || thisTh-&gt;status==RUN)) {\n    thisTh-&gt;status= READY;\n    nth_putBack(nth_pri1ReadyQueue[thisTh-&gt;pri], thisTh);\n  }\n  nThread nextTh= NULL;\n  while (nextTh==NULL) {\n    int i=0;\n    while (i&lt;MAXPRI) {\n      if (!nth_emptyQueue(nth_pri1ReadyQueue[i]))\n        break;\n      i++;\n    }\n    if (i&lt;MAXPRI) {\n      nextTh= nth_getFront(nth_pri1ReadyQueue[i]);\n      break;\n    }\n    else {\n      nth_coreIsIdle[0]= 1; \n      sigsuspend(&nth_sigsetApp);\n      nth_coreIsIdle[0]= 0;\n    }\n  }\n  \n  nth_changeContext(thisTh, nextTh);\n\n  nth_setSelf(thisTh); \n  \n  thisTh-&gt;status= RUN;\n}\n\n\n\nAl llamar a schedule() buscamos suspender el thread para darle el core al que tenga mejor prioridad.\nSi el thread no esta suspendido (WAIT) se reincorpora a las colas de prioridades.\nSe debe mantener schedule() hasta obtener el siguiente thread.\nBuscamos la cola con mejor prioridad.\nSi encontramos dicha cola, obtenemos el primer thread en esta.\nSi no, tenemos que suspender el thread."
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-14",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-14",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Schedule(void) {\n  CHECK_CRITICAL(\"nth_fcfsSchedule\")\n  \n  nThread thisTh= nSelf();\n  if (thisTh!=NULL && (thisTh-&gt;status==READY || thisTh-&gt;status==RUN)) {\n    thisTh-&gt;status= READY;\n    nth_putBack(nth_pri1ReadyQueue[thisTh-&gt;pri], thisTh);\n  }\n  nThread nextTh= NULL;\n  while (nextTh==NULL) {\n    int i=0;\n    while (i&lt;MAXPRI) {\n      if (!nth_emptyQueue(nth_pri1ReadyQueue[i]))\n        break;\n      i++;\n    }\n    if (i&lt;MAXPRI) {\n      nextTh= nth_getFront(nth_pri1ReadyQueue[i]);\n      break;\n    }\n    else {\n      nth_coreIsIdle[0]= 1; \n      sigsuspend(&nth_sigsetApp);\n      nth_coreIsIdle[0]= 0;\n    }\n  }\n  \n  nth_changeContext(thisTh, nextTh);\n\n  nth_setSelf(thisTh); \n  \n  thisTh-&gt;status= RUN;\n}\n\n\n\nAl llamar a schedule() buscamos suspender el thread para darle el core al que tenga mejor prioridad.\nSi el thread no esta suspendido (WAIT) se reincorpora a las colas de prioridades.\nSe debe mantener schedule() hasta obtener el siguiente thread.\nBuscamos la cola con mejor prioridad.\nSi encontramos dicha cola, obtenemos el primer thread en esta.\nSi no, tenemos que suspender el thread.\n\nEsto significa que no existe otro thread que este listo para ejecutar."
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-15",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-15",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Schedule(void) {\n  CHECK_CRITICAL(\"nth_fcfsSchedule\")\n  \n  nThread thisTh= nSelf();\n  if (thisTh!=NULL && (thisTh-&gt;status==READY || thisTh-&gt;status==RUN)) {\n    thisTh-&gt;status= READY;\n    nth_putBack(nth_pri1ReadyQueue[thisTh-&gt;pri], thisTh);\n  }\n  nThread nextTh= NULL;\n  while (nextTh==NULL) {\n    int i=0;\n    while (i&lt;MAXPRI) {\n      if (!nth_emptyQueue(nth_pri1ReadyQueue[i]))\n        break;\n      i++;\n    }\n    if (i&lt;MAXPRI) {\n      nextTh= nth_getFront(nth_pri1ReadyQueue[i]);\n      break;\n    }\n    else {\n      nth_coreIsIdle[0]= 1; \n      sigsuspend(&nth_sigsetApp);\n      nth_coreIsIdle[0]= 0;\n    }\n  }\n  \n  nth_changeContext(thisTh, nextTh);\n\n  nth_setSelf(thisTh); \n  \n  thisTh-&gt;status= RUN;\n}\n\n\n\nAl llamar a schedule() buscamos suspender el thread para darle el core al que tenga mejor prioridad.\nSi el thread no esta suspendido (WAIT) se reincorpora a las colas de prioridades.\nSe debe mantener schedule() hasta obtener el siguiente thread.\nBuscamos la cola con mejor prioridad.\nSi encontramos dicha cola, obtenemos el primer thread en esta.\nSi no, tenemos que suspender el thread.\n\nEsto significa que no existe otro thread que este listo para ejecutar.\nSe tiene que marcar entonces que el sistema entero (o el core) como idle."
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-16",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-16",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Schedule(void) {\n  CHECK_CRITICAL(\"nth_fcfsSchedule\")\n  \n  nThread thisTh= nSelf();\n  if (thisTh!=NULL && (thisTh-&gt;status==READY || thisTh-&gt;status==RUN)) {\n    thisTh-&gt;status= READY;\n    nth_putBack(nth_pri1ReadyQueue[thisTh-&gt;pri], thisTh);\n  }\n  nThread nextTh= NULL;\n  while (nextTh==NULL) {\n    int i=0;\n    while (i&lt;MAXPRI) {\n      if (!nth_emptyQueue(nth_pri1ReadyQueue[i]))\n        break;\n      i++;\n    }\n    if (i&lt;MAXPRI) {\n      nextTh= nth_getFront(nth_pri1ReadyQueue[i]);\n      break;\n    }\n    else {\n      nth_coreIsIdle[0]= 1; \n      sigsuspend(&nth_sigsetApp);\n      nth_coreIsIdle[0]= 0;\n    }\n  }\n  \n  nth_changeContext(thisTh, nextTh);\n\n  nth_setSelf(thisTh); \n  \n  thisTh-&gt;status= RUN;\n}\n\n\n\nCuando obtenemos el thread le pasamos el core correspondiente."
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-17",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-17",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Schedule(void) {\n  CHECK_CRITICAL(\"nth_fcfsSchedule\")\n  \n  nThread thisTh= nSelf();\n  if (thisTh!=NULL && (thisTh-&gt;status==READY || thisTh-&gt;status==RUN)) {\n    thisTh-&gt;status= READY;\n    nth_putBack(nth_pri1ReadyQueue[thisTh-&gt;pri], thisTh);\n  }\n  nThread nextTh= NULL;\n  while (nextTh==NULL) {\n    int i=0;\n    while (i&lt;MAXPRI) {\n      if (!nth_emptyQueue(nth_pri1ReadyQueue[i]))\n        break;\n      i++;\n    }\n    if (i&lt;MAXPRI) {\n      nextTh= nth_getFront(nth_pri1ReadyQueue[i]);\n      break;\n    }\n    else {\n      nth_coreIsIdle[0]= 1; \n      sigsuspend(&nth_sigsetApp);\n      nth_coreIsIdle[0]= 0;\n    }\n  }\n  \n  nth_changeContext(thisTh, nextTh);\n\n  nth_setSelf(thisTh); \n  \n  thisTh-&gt;status= RUN;\n}\n\n\n\nCuando obtenemos el thread le pasamos el core correspondiente.\nEsto hace que se suspenda la ejecuci√≥n de la funci√≥n"
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-18",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-18",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Schedule(void) {\n  CHECK_CRITICAL(\"nth_fcfsSchedule\")\n  \n  nThread thisTh= nSelf();\n  if (thisTh!=NULL && (thisTh-&gt;status==READY || thisTh-&gt;status==RUN)) {\n    thisTh-&gt;status= READY;\n    nth_putBack(nth_pri1ReadyQueue[thisTh-&gt;pri], thisTh);\n  }\n  nThread nextTh= NULL;\n  while (nextTh==NULL) {\n    int i=0;\n    while (i&lt;MAXPRI) {\n      if (!nth_emptyQueue(nth_pri1ReadyQueue[i]))\n        break;\n      i++;\n    }\n    if (i&lt;MAXPRI) {\n      nextTh= nth_getFront(nth_pri1ReadyQueue[i]);\n      break;\n    }\n    else {\n      nth_coreIsIdle[0]= 1; \n      sigsuspend(&nth_sigsetApp);\n      nth_coreIsIdle[0]= 0;\n    }\n  }\n  \n  nth_changeContext(thisTh, nextTh);\n\n  nth_setSelf(thisTh); \n  \n  thisTh-&gt;status= RUN;\n}\n\n\n\nCuando obtenemos el thread le pasamos el core correspondiente.\nEsto hace que se suspenda la ejecuci√≥n de la funci√≥n\nDespu√©s de un rato, el thread vuelve a recibir un core"
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-19",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-19",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Schedule(void) {\n  CHECK_CRITICAL(\"nth_fcfsSchedule\")\n  \n  nThread thisTh= nSelf();\n  if (thisTh!=NULL && (thisTh-&gt;status==READY || thisTh-&gt;status==RUN)) {\n    thisTh-&gt;status= READY;\n    nth_putBack(nth_pri1ReadyQueue[thisTh-&gt;pri], thisTh);\n  }\n  nThread nextTh= NULL;\n  while (nextTh==NULL) {\n    int i=0;\n    while (i&lt;MAXPRI) {\n      if (!nth_emptyQueue(nth_pri1ReadyQueue[i]))\n        break;\n      i++;\n    }\n    if (i&lt;MAXPRI) {\n      nextTh= nth_getFront(nth_pri1ReadyQueue[i]);\n      break;\n    }\n    else {\n      nth_coreIsIdle[0]= 1; \n      sigsuspend(&nth_sigsetApp);\n      nth_coreIsIdle[0]= 0;\n    }\n  }\n  \n  nth_changeContext(thisTh, nextTh);\n\n  nth_setSelf(thisTh); \n  \n  thisTh-&gt;status= RUN;\n}\n\n\n\nCuando obtenemos el thread le pasamos el core correspondiente.\nEsto hace que se suspenda la ejecuci√≥n de la funci√≥n\nDespu√©s de un rato, el thread vuelve a recibir un core\nEste core puede que sea distinto al que tenia al principio"
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-20",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-20",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Schedule(void) {\n  CHECK_CRITICAL(\"nth_fcfsSchedule\")\n  \n  nThread thisTh= nSelf();\n  if (thisTh!=NULL && (thisTh-&gt;status==READY || thisTh-&gt;status==RUN)) {\n    thisTh-&gt;status= READY;\n    nth_putBack(nth_pri1ReadyQueue[thisTh-&gt;pri], thisTh);\n  }\n  nThread nextTh= NULL;\n  while (nextTh==NULL) {\n    int i=0;\n    while (i&lt;MAXPRI) {\n      if (!nth_emptyQueue(nth_pri1ReadyQueue[i]))\n        break;\n      i++;\n    }\n    if (i&lt;MAXPRI) {\n      nextTh= nth_getFront(nth_pri1ReadyQueue[i]);\n      break;\n    }\n    else {\n      nth_coreIsIdle[0]= 1; \n      sigsuspend(&nth_sigsetApp);\n      nth_coreIsIdle[0]= 0;\n    }\n  }\n  \n  nth_changeContext(thisTh, nextTh);\n\n  nth_setSelf(thisTh); \n  \n  thisTh-&gt;status= RUN;\n}\n\n\n\nCuando obtenemos el thread le pasamos el core correspondiente.\nEsto hace que se suspenda la ejecuci√≥n de la funci√≥n\nDespu√©s de un rato, el thread vuelve a recibir un core\nEste core puede que sea distinto al que tenia al principio\nHay que reconfigurar el thread."
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-21",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-21",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Schedule(void) {\n  CHECK_CRITICAL(\"nth_fcfsSchedule\")\n  \n  nThread thisTh= nSelf();\n  if (thisTh!=NULL && (thisTh-&gt;status==READY || thisTh-&gt;status==RUN)) {\n    thisTh-&gt;status= READY;\n    nth_putBack(nth_pri1ReadyQueue[thisTh-&gt;pri], thisTh);\n  }\n  nThread nextTh= NULL;\n  while (nextTh==NULL) {\n    int i=0;\n    while (i&lt;MAXPRI) {\n      if (!nth_emptyQueue(nth_pri1ReadyQueue[i]))\n        break;\n      i++;\n    }\n    if (i&lt;MAXPRI) {\n      nextTh= nth_getFront(nth_pri1ReadyQueue[i]);\n      break;\n    }\n    else {\n      nth_coreIsIdle[0]= 1; \n      sigsuspend(&nth_sigsetApp);\n      nth_coreIsIdle[0]= 0;\n    }\n  }\n  \n  nth_changeContext(thisTh, nextTh);\n\n  nth_setSelf(thisTh); \n  \n  thisTh-&gt;status= RUN;\n}\n\n\n\nCuando obtenemos el thread le pasamos el core correspondiente.\nEsto hace que se suspenda la ejecuci√≥n de la funci√≥n\nDespu√©s de un rato, el thread vuelve a recibir un core\nEste core puede que sea distinto al que tenia al principio\nHay que reconfigurar el thread.\nDespu√©s de esto, nSelf() retorna correctamente el thread actual."
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-22",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-22",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Schedule(void) {\n  CHECK_CRITICAL(\"nth_fcfsSchedule\")\n  \n  nThread thisTh= nSelf();\n  if (thisTh!=NULL && (thisTh-&gt;status==READY || thisTh-&gt;status==RUN)) {\n    thisTh-&gt;status= READY;\n    nth_putBack(nth_pri1ReadyQueue[thisTh-&gt;pri], thisTh);\n  }\n  nThread nextTh= NULL;\n  while (nextTh==NULL) {\n    int i=0;\n    while (i&lt;MAXPRI) {\n      if (!nth_emptyQueue(nth_pri1ReadyQueue[i]))\n        break;\n      i++;\n    }\n    if (i&lt;MAXPRI) {\n      nextTh= nth_getFront(nth_pri1ReadyQueue[i]);\n      break;\n    }\n    else {\n      nth_coreIsIdle[0]= 1; \n      sigsuspend(&nth_sigsetApp);\n      nth_coreIsIdle[0]= 0;\n    }\n  }\n  \n  nth_changeContext(thisTh, nextTh);\n\n  nth_setSelf(thisTh); \n  \n  thisTh-&gt;status= RUN;\n}\n\n\n\nCuando obtenemos el thread le pasamos el core correspondiente.\nEsto hace que se suspenda la ejecuci√≥n de la funci√≥n\nDespu√©s de un rato, el thread vuelve a recibir un core\nEste core puede que sea distinto al que tenia al principio\nHay que reconfigurar el thread.\nDespu√©s de esto, nSelf() retorna correctamente el thread actual.\nSe cambia el estado del thread."
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-23",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-23",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Stop(void) {\n  CHECK_CRITICAL(\"nth_fcfsStop\")\n  \n  for (int i= 0; i&lt;MAXPRI; i++)\n    nth_destroyQueue(nth_pri1ReadyQueue[i]);\n}\n\nScheduler nth_pri1Scheduler= { .schedule = nth_pri1Schedule,\n                               .setReady = nth_pri1SetReady,\n                               .suspend = nth_pri1Suspend,\n                               .stop = nth_pri1Stop };\n\nvoid setPri1Scheduling() {\n  START_CRITICAL\n\n  if (nth_verbose)\n    printf(\"Info: setting single-core priority scheduling\\n\");\n  \n  if (nth_totalCores!=1)\n    nFatalError(\"setPri1Scheduling\",\n                \"This priority scheduler only accepts a single core\\n\");\n  for (int i= 0; i&lt;MAXPRI; i++)\n    nth_pri1ReadyQueue[i]= nth_makeQueue();\n  nth_setScheduler(nth_pri1Scheduler);\n  MapIterator *iter= getMapIterator(nth_threadSet);\n  void *ptr;\n  while (mapNext(iter, &ptr, &ptr)) {\n    nThread th= ptr;\n    if (th-&gt;status==READY)\n      nth_putBack(nth_pri1ReadyQueue[th-&gt;pri], th);\n  }\n  destroyMapIterator(iter);\n  \n  END_CRITICAL\n}\n\nint isPri1Scheduling(void) {\n  return nth_scheduler.schedule==nth_pri1Scheduler.schedule;\n}"
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-24",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-24",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Stop(void) {\n  CHECK_CRITICAL(\"nth_fcfsStop\")\n  \n  for (int i= 0; i&lt;MAXPRI; i++)\n    nth_destroyQueue(nth_pri1ReadyQueue[i]);\n}\n\nScheduler nth_pri1Scheduler= { .schedule = nth_pri1Schedule,\n                               .setReady = nth_pri1SetReady,\n                               .suspend = nth_pri1Suspend,\n                               .stop = nth_pri1Stop };\n\nvoid setPri1Scheduling() {\n  START_CRITICAL\n\n  if (nth_verbose)\n    printf(\"Info: setting single-core priority scheduling\\n\");\n  \n  if (nth_totalCores!=1)\n    nFatalError(\"setPri1Scheduling\",\n                \"This priority scheduler only accepts a single core\\n\");\n  for (int i= 0; i&lt;MAXPRI; i++)\n    nth_pri1ReadyQueue[i]= nth_makeQueue();\n  nth_setScheduler(nth_pri1Scheduler);\n  MapIterator *iter= getMapIterator(nth_threadSet);\n  void *ptr;\n  while (mapNext(iter, &ptr, &ptr)) {\n    nThread th= ptr;\n    if (th-&gt;status==READY)\n      nth_putBack(nth_pri1ReadyQueue[th-&gt;pri], th);\n  }\n  destroyMapIterator(iter);\n  \n  END_CRITICAL\n}\n\nint isPri1Scheduling(void) {\n  return nth_scheduler.schedule==nth_pri1Scheduler.schedule;\n}\n\n\n\nEl scheduler se maneja como una estructura con punteros a las funciones adecuadas."
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-25",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-25",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Stop(void) {\n  CHECK_CRITICAL(\"nth_fcfsStop\")\n  \n  for (int i= 0; i&lt;MAXPRI; i++)\n    nth_destroyQueue(nth_pri1ReadyQueue[i]);\n}\n\nScheduler nth_pri1Scheduler= { .schedule = nth_pri1Schedule,\n                               .setReady = nth_pri1SetReady,\n                               .suspend = nth_pri1Suspend,\n                               .stop = nth_pri1Stop };\n\nvoid setPri1Scheduling() {\n  START_CRITICAL\n\n  if (nth_verbose)\n    printf(\"Info: setting single-core priority scheduling\\n\");\n  \n  if (nth_totalCores!=1)\n    nFatalError(\"setPri1Scheduling\",\n                \"This priority scheduler only accepts a single core\\n\");\n  for (int i= 0; i&lt;MAXPRI; i++)\n    nth_pri1ReadyQueue[i]= nth_makeQueue();\n  nth_setScheduler(nth_pri1Scheduler);\n  MapIterator *iter= getMapIterator(nth_threadSet);\n  void *ptr;\n  while (mapNext(iter, &ptr, &ptr)) {\n    nThread th= ptr;\n    if (th-&gt;status==READY)\n      nth_putBack(nth_pri1ReadyQueue[th-&gt;pri], th);\n  }\n  destroyMapIterator(iter);\n  \n  END_CRITICAL\n}\n\nint isPri1Scheduling(void) {\n  return nth_scheduler.schedule==nth_pri1Scheduler.schedule;\n}\n\n\n\nEl scheduler se maneja como una estructura con punteros a las funciones adecuadas.\nPara inicializar el scheduler:"
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-26",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-26",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Stop(void) {\n  CHECK_CRITICAL(\"nth_fcfsStop\")\n  \n  for (int i= 0; i&lt;MAXPRI; i++)\n    nth_destroyQueue(nth_pri1ReadyQueue[i]);\n}\n\nScheduler nth_pri1Scheduler= { .schedule = nth_pri1Schedule,\n                               .setReady = nth_pri1SetReady,\n                               .suspend = nth_pri1Suspend,\n                               .stop = nth_pri1Stop };\n\nvoid setPri1Scheduling() {\n  START_CRITICAL\n\n  if (nth_verbose)\n    printf(\"Info: setting single-core priority scheduling\\n\");\n  \n  if (nth_totalCores!=1)\n    nFatalError(\"setPri1Scheduling\",\n                \"This priority scheduler only accepts a single core\\n\");\n  for (int i= 0; i&lt;MAXPRI; i++)\n    nth_pri1ReadyQueue[i]= nth_makeQueue();\n  nth_setScheduler(nth_pri1Scheduler);\n  MapIterator *iter= getMapIterator(nth_threadSet);\n  void *ptr;\n  while (mapNext(iter, &ptr, &ptr)) {\n    nThread th= ptr;\n    if (th-&gt;status==READY)\n      nth_putBack(nth_pri1ReadyQueue[th-&gt;pri], th);\n  }\n  destroyMapIterator(iter);\n  \n  END_CRITICAL\n}\n\nint isPri1Scheduling(void) {\n  return nth_scheduler.schedule==nth_pri1Scheduler.schedule;\n}\n\n\n\nEl scheduler se maneja como una estructura con punteros a las funciones adecuadas.\nPara inicializar el scheduler:\n\nHay que crear las colas de prioridad"
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-27",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-27",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Stop(void) {\n  CHECK_CRITICAL(\"nth_fcfsStop\")\n  \n  for (int i= 0; i&lt;MAXPRI; i++)\n    nth_destroyQueue(nth_pri1ReadyQueue[i]);\n}\n\nScheduler nth_pri1Scheduler= { .schedule = nth_pri1Schedule,\n                               .setReady = nth_pri1SetReady,\n                               .suspend = nth_pri1Suspend,\n                               .stop = nth_pri1Stop };\n\nvoid setPri1Scheduling() {\n  START_CRITICAL\n\n  if (nth_verbose)\n    printf(\"Info: setting single-core priority scheduling\\n\");\n  \n  if (nth_totalCores!=1)\n    nFatalError(\"setPri1Scheduling\",\n                \"This priority scheduler only accepts a single core\\n\");\n  for (int i= 0; i&lt;MAXPRI; i++)\n    nth_pri1ReadyQueue[i]= nth_makeQueue();\n  nth_setScheduler(nth_pri1Scheduler);\n  MapIterator *iter= getMapIterator(nth_threadSet);\n  void *ptr;\n  while (mapNext(iter, &ptr, &ptr)) {\n    nThread th= ptr;\n    if (th-&gt;status==READY)\n      nth_putBack(nth_pri1ReadyQueue[th-&gt;pri], th);\n  }\n  destroyMapIterator(iter);\n  \n  END_CRITICAL\n}\n\nint isPri1Scheduling(void) {\n  return nth_scheduler.schedule==nth_pri1Scheduler.schedule;\n}\n\n\n\nEl scheduler se maneja como una estructura con punteros a las funciones adecuadas.\nPara inicializar el scheduler:\n\nHay que crear las colas de prioridad"
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-28",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-28",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Stop(void) {\n  CHECK_CRITICAL(\"nth_fcfsStop\")\n  \n  for (int i= 0; i&lt;MAXPRI; i++)\n    nth_destroyQueue(nth_pri1ReadyQueue[i]);\n}\n\nScheduler nth_pri1Scheduler= { .schedule = nth_pri1Schedule,\n                               .setReady = nth_pri1SetReady,\n                               .suspend = nth_pri1Suspend,\n                               .stop = nth_pri1Stop };\n\nvoid setPri1Scheduling() {\n  START_CRITICAL\n\n  if (nth_verbose)\n    printf(\"Info: setting single-core priority scheduling\\n\");\n  \n  if (nth_totalCores!=1)\n    nFatalError(\"setPri1Scheduling\",\n                \"This priority scheduler only accepts a single core\\n\");\n  for (int i= 0; i&lt;MAXPRI; i++)\n    nth_pri1ReadyQueue[i]= nth_makeQueue();\n  nth_setScheduler(nth_pri1Scheduler);\n  MapIterator *iter= getMapIterator(nth_threadSet);\n  void *ptr;\n  while (mapNext(iter, &ptr, &ptr)) {\n    nThread th= ptr;\n    if (th-&gt;status==READY)\n      nth_putBack(nth_pri1ReadyQueue[th-&gt;pri], th);\n  }\n  destroyMapIterator(iter);\n  \n  END_CRITICAL\n}\n\nint isPri1Scheduling(void) {\n  return nth_scheduler.schedule==nth_pri1Scheduler.schedule;\n}\n\n\n\nEl scheduler se maneja como una estructura con punteros a las funciones adecuadas.\nPara inicializar el scheduler:\n\nHay que crear las colas de prioridad\nIterar por los threads y colocarlos en la cola adecuada"
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-29",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-29",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Stop(void) {\n  CHECK_CRITICAL(\"nth_fcfsStop\")\n  \n  for (int i= 0; i&lt;MAXPRI; i++)\n    nth_destroyQueue(nth_pri1ReadyQueue[i]);\n}\n\nScheduler nth_pri1Scheduler= { .schedule = nth_pri1Schedule,\n                               .setReady = nth_pri1SetReady,\n                               .suspend = nth_pri1Suspend,\n                               .stop = nth_pri1Stop };\n\nvoid setPri1Scheduling() {\n  START_CRITICAL\n\n  if (nth_verbose)\n    printf(\"Info: setting single-core priority scheduling\\n\");\n  \n  if (nth_totalCores!=1)\n    nFatalError(\"setPri1Scheduling\",\n                \"This priority scheduler only accepts a single core\\n\");\n  for (int i= 0; i&lt;MAXPRI; i++)\n    nth_pri1ReadyQueue[i]= nth_makeQueue();\n  nth_setScheduler(nth_pri1Scheduler);\n  MapIterator *iter= getMapIterator(nth_threadSet);\n  void *ptr;\n  while (mapNext(iter, &ptr, &ptr)) {\n    nThread th= ptr;\n    if (th-&gt;status==READY)\n      nth_putBack(nth_pri1ReadyQueue[th-&gt;pri], th);\n  }\n  destroyMapIterator(iter);\n  \n  END_CRITICAL\n}\n\nint isPri1Scheduling(void) {\n  return nth_scheduler.schedule==nth_pri1Scheduler.schedule;\n}\n\n\n\nEl scheduler se maneja como una estructura con punteros a las funciones adecuadas.\nPara inicializar el scheduler:\n\nHay que crear las colas de prioridad\nIterar por los threads y colocarlos en la cola adecuada\n\nPara terminar el scheduler:"
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-30",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-30",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Stop(void) {\n  CHECK_CRITICAL(\"nth_fcfsStop\")\n  \n  for (int i= 0; i&lt;MAXPRI; i++)\n    nth_destroyQueue(nth_pri1ReadyQueue[i]);\n}\n\nScheduler nth_pri1Scheduler= { .schedule = nth_pri1Schedule,\n                               .setReady = nth_pri1SetReady,\n                               .suspend = nth_pri1Suspend,\n                               .stop = nth_pri1Stop };\n\nvoid setPri1Scheduling() {\n  START_CRITICAL\n\n  if (nth_verbose)\n    printf(\"Info: setting single-core priority scheduling\\n\");\n  \n  if (nth_totalCores!=1)\n    nFatalError(\"setPri1Scheduling\",\n                \"This priority scheduler only accepts a single core\\n\");\n  for (int i= 0; i&lt;MAXPRI; i++)\n    nth_pri1ReadyQueue[i]= nth_makeQueue();\n  nth_setScheduler(nth_pri1Scheduler);\n  MapIterator *iter= getMapIterator(nth_threadSet);\n  void *ptr;\n  while (mapNext(iter, &ptr, &ptr)) {\n    nThread th= ptr;\n    if (th-&gt;status==READY)\n      nth_putBack(nth_pri1ReadyQueue[th-&gt;pri], th);\n  }\n  destroyMapIterator(iter);\n  \n  END_CRITICAL\n}\n\nint isPri1Scheduling(void) {\n  return nth_scheduler.schedule==nth_pri1Scheduler.schedule;\n}\n\n\n\nEl scheduler se maneja como una estructura con punteros a las funciones adecuadas.\nPara inicializar el scheduler:\n\nHay que crear las colas de prioridad\nIterar por los threads y colocarlos en la cola adecuada\n\nPara terminar el scheduler:\n\nHay que destruir las colas de prioridad"
  },
  {
    "objectID": "courses/4302.7.html#p2-scheduler-de-prioridades-31",
    "href": "courses/4302.7.html#p2-scheduler-de-prioridades-31",
    "title": "Auxiliar 7",
    "section": "P2 ‚Äì Scheduler de prioridades",
    "text": "P2 ‚Äì Scheduler de prioridades\n\n\nstatic void nth_pri1Stop(void) {\n  CHECK_CRITICAL(\"nth_fcfsStop\")\n  \n  for (int i= 0; i&lt;MAXPRI; i++)\n    nth_destroyQueue(nth_pri1ReadyQueue[i]);\n}\n\nScheduler nth_pri1Scheduler= { .schedule = nth_pri1Schedule,\n                               .setReady = nth_pri1SetReady,\n                               .suspend = nth_pri1Suspend,\n                               .stop = nth_pri1Stop };\n\nvoid setPri1Scheduling() {\n  START_CRITICAL\n\n  if (nth_verbose)\n    printf(\"Info: setting single-core priority scheduling\\n\");\n  \n  if (nth_totalCores!=1)\n    nFatalError(\"setPri1Scheduling\",\n                \"This priority scheduler only accepts a single core\\n\");\n  for (int i= 0; i&lt;MAXPRI; i++)\n    nth_pri1ReadyQueue[i]= nth_makeQueue();\n  nth_setScheduler(nth_pri1Scheduler);\n  MapIterator *iter= getMapIterator(nth_threadSet);\n  void *ptr;\n  while (mapNext(iter, &ptr, &ptr)) {\n    nThread th= ptr;\n    if (th-&gt;status==READY)\n      nth_putBack(nth_pri1ReadyQueue[th-&gt;pri], th);\n  }\n  destroyMapIterator(iter);\n  \n  END_CRITICAL\n}\n\nint isPri1Scheduling(void) {\n  return nth_scheduler.schedule==nth_pri1Scheduler.schedule;\n}\n\n\n\nEl scheduler se maneja como una estructura con punteros a las funciones adecuadas.\nPara inicializar el scheduler:\n\nHay que crear las colas de prioridad\nIterar por los threads y colocarlos en la cola adecuada\n\nPara terminar el scheduler:\n\nHay que destruir las colas de prioridad"
  },
  {
    "objectID": "courses/3501.0.html",
    "href": "courses/3501.0.html",
    "title": "Modelaci√≥n y Computaci√≥n Gr√°fica para Ingeniero",
    "section": "",
    "text": "Instalaci√≥n de Herramientas\nIntroducci√≥n a OpenGL\nC√°mara e Input\nTexturas e Iluminaci√≥n\nMateriales y Luces",
    "crumbs": [
      "Cursos",
      "2024",
      "Modelaci√≥n y Computaci√≥n Gr√°fica para Ingeniero"
    ]
  },
  {
    "objectID": "courses/3501.0.html#auxiliares",
    "href": "courses/3501.0.html#auxiliares",
    "title": "Modelaci√≥n y Computaci√≥n Gr√°fica para Ingeniero",
    "section": "",
    "text": "Instalaci√≥n de Herramientas\nIntroducci√≥n a OpenGL\nC√°mara e Input\nTexturas e Iluminaci√≥n\nMateriales y Luces",
    "crumbs": [
      "Cursos",
      "2024",
      "Modelaci√≥n y Computaci√≥n Gr√°fica para Ingeniero"
    ]
  },
  {
    "objectID": "courses/3501.4.html#espacios-3d",
    "href": "courses/3501.4.html#espacios-3d",
    "title": "Auxiliar 4",
    "section": "Espacios 3D",
    "text": "Espacios 3D\n\nPara trabajar en tres dimensiones tenemos que tener en cuenta los espacios de nuestros objetos:\n\n\n\nLocal space\nSe corresponden con las coordenadas originales o locales del objeto, se suelen dejar homog√©neas para despu√©s manipularlas con facilidad.\nWorld space\nCorresponde al mundo donde se ubica los objetos, cada objeto tiene una posici√≥n, orientaci√≥n y tama√±o en este.\nView space\nEs el mundo que se esta viendo, por lo tanto, es solo una porci√≥n del mundo y esta vinculado a la c√°mara de la escena\nClip space\nEs espacio h√≥mogeneo de OpenGL, desde -1 a 1 en todas las coordenadas, lo que queda fuera se elimina o recorta"
  },
  {
    "objectID": "courses/3501.4.html#espacios-3d-1",
    "href": "courses/3501.4.html#espacios-3d-1",
    "title": "Auxiliar 4",
    "section": "Espacios 3D",
    "text": "Espacios 3D\n\n\n\n\n\n\n\nFuente: LearnOpenGL"
  },
  {
    "objectID": "courses/3501.4.html#espacios-3d-2",
    "href": "courses/3501.4.html#espacios-3d-2",
    "title": "Auxiliar 4",
    "section": "Espacios 3D",
    "text": "Espacios 3D\nMatriz MVP\n\n\\[\nM_{projection} \\cdot M_{view} \\cdot M_{model} \\cdot v_{local} = v_{clipped}\n\\]\n\n\nSirve para moverse desde el espacio local al espacio homog√©neo de OpenGL"
  },
  {
    "objectID": "courses/3501.4.html#modelo",
    "href": "courses/3501.4.html#modelo",
    "title": "Auxiliar 4",
    "section": "Modelo",
    "text": "Modelo\n\nPara pasar de coordenadas locales a las de mundo usamos la matriz de modelo.\n\n\n\\[\nM_{model}  = M_{translation} \\cdot M_{rotation} \\cdot M_{scale}\n\\]\n\n\nEs la que usamos la clase pasada para mover los modelos!"
  },
  {
    "objectID": "courses/3501.4.html#vista",
    "href": "courses/3501.4.html#vista",
    "title": "Auxiliar 4",
    "section": "Vista",
    "text": "Vista\n\nPara pasar de coordenadas de mundo a las de vista o de c√°mara, usamos la matriz de vista. Con un poco de magia de √°lgebra lineal tenemos que:\n\n\n\\[\nM_{view} = M_{lookat} =\n\\begin{pmatrix}\nr_x & r_y & r_z & 0\\\\\nu_x & u_y & u_z & 0\\\\\nd_x & d_y & d_z & 0\\\\\n0 & 0 & 0 & 1\\\\\n\\end{pmatrix}\n\\cdot\n\\begin{pmatrix}\n1 & 0 & 0 & -p_x\\\\\n0 & 1 & 0 & -p_y\\\\\n0 & 0 & 1 & -p_z\\\\\n0 & 0 & 0 & 1\\\\\n\\end{pmatrix}\n\\]\n\n\nDonde\n\n\\(R\\) es el vector que apunta a la derecha de la c√°mara\n\\(U\\) es el vector que apunta hacia arriba de la c√°mara\n\\(D\\) es el vector a donde apunta a la c√°mara\n\\(P\\) es la posici√≥n de la c√°mara"
  },
  {
    "objectID": "courses/3501.4.html#proyecci√≥n",
    "href": "courses/3501.4.html#proyecci√≥n",
    "title": "Auxiliar 4",
    "section": "Proyecci√≥n",
    "text": "Proyecci√≥n\n\nFinalmente, para pasar de las coordenadas de vista a las homog√©neas de OpenGL se usa la matriz de proyecci√≥n, que viene en dos sabores:\n\n\n\n\nOrtogr√°fica\n\n\n\n\n\ndef ortho(left, right, bottom, top, near, far)\n\n\nPerspectiva\n\n\n\n\n\ndef perspective(fovy, aspect, near, far):\n\n\n\nFuente: LearnOpenGL"
  },
  {
    "objectID": "courses/3501.4.html#manejo-de-input",
    "href": "courses/3501.4.html#manejo-de-input",
    "title": "Auxiliar 4",
    "section": "Manejo de input",
    "text": "Manejo de input\n\nPara manejar input podemos utilizar Pyglet la cual nos provee funciones que son llamadas durante el ciclo del juego, similar a on_draw:\n\n\n\non_key_press(symbol, modifiers): funci√≥n que se llama cuando se presiona una tecla y se guarda el valor de la tecla en symbol.\non_key_release(symbol, modifiers): funci√≥n que se llama cuando se libera una tecla y se guarda el valor de la tecla en symbol.\non_mouse_motion(x, y, dx, dy): funci√≥n que se llama cuando el mouse se mueve y guarda la posici√≥n del mouse en la ventana (x e y), as√≠ como el cambio de este (dx y dy).\n\n\n\nExisten m√°s que pueden ver en la documentaci√≥n de la librer√≠a"
  },
  {
    "objectID": "courses/3501.4.html#p1-hacerlo-con-clase",
    "href": "courses/3501.4.html#p1-hacerlo-con-clase",
    "title": "Auxiliar 4",
    "section": "P1 ‚Äî Hacerlo con clase",
    "text": "P1 ‚Äî Hacerlo con clase\n\nEl auxiliar pasado vieron realizar un mont√≥n de transformaciones para alterar los modelos, ahora veremos como abstraer el concepto de modelo en una clase.\n\n\nUna clase es una forma que se tiene para empaquetar c√≥digo, la idea es que cada clase represente algo.\n\n\nCree la clase GameModel, que contenga lo siguiente:\n\nInformaci√≥n de posici√≥n, rotaci√≥n y escalado\nColor del objeto y buffer de la GPU\nUna funci√≥n que sea capaz de entregar la matriz de modelo del objeto correspondiente\nUna funci√≥n que sea capaz de dibujar el objeto en pantalla"
  },
  {
    "objectID": "courses/3501.4.html#p1-hacerlo-con-clase-1",
    "href": "courses/3501.4.html#p1-hacerlo-con-clase-1",
    "title": "Auxiliar 4",
    "section": "P1 ‚Äî Hacerlo con clase",
    "text": "P1 ‚Äî Hacerlo con clase\nUse esta clase junto a sus nuevos conocimientos para recrear la siguiente escena:"
  },
  {
    "objectID": "courses/3501.4.html#p2-hag√°moslo-fps",
    "href": "courses/3501.4.html#p2-hag√°moslo-fps",
    "title": "Auxiliar 4",
    "section": "P2 ‚Äì Hag√°moslo FPS",
    "text": "P2 ‚Äì Hag√°moslo FPS\n\n\nParte A\nMuy bonita su escena pero hay elementos que no se ven completamente, como usted conoce ahora la potente matriz MVP, le gustar√≠a poder moverse en su escena.\n\n\nCree la clase Camara que contenga informaci√≥n de la posici√≥n de la c√°mara y su velocidad y use el teclado para moverse en la escena usando on_key_press y on_key_release"
  },
  {
    "objectID": "courses/3501.4.html#p2-hag√°moslo-fps-1",
    "href": "courses/3501.4.html#p2-hag√°moslo-fps-1",
    "title": "Auxiliar 4",
    "section": "P2 ‚Äì Hag√°moslo FPS",
    "text": "P2 ‚Äì Hag√°moslo FPS\n\n\nParte B\nA√±ada los valores de pitch y yaw que permitan mover la c√°mara, use la funci√≥n on_mouse_motion para vincular el √°ngulo de vista con el movimiento del mouse"
  },
  {
    "objectID": "courses/3501.4.html#p2-hag√°moslo-fps-2",
    "href": "courses/3501.4.html#p2-hag√°moslo-fps-2",
    "title": "Auxiliar 4",
    "section": "P2 ‚Äì Hag√°moslo FPS",
    "text": "P2 ‚Äì Hag√°moslo FPS\n\n\nParte C\nCorrija el movimiento de la parte A para que este sincronizado con la direcci√≥n de la c√°mara\n\n\n\n\n\n\n\n\n\nFelicidades! Ahora puedes hacer un 360 no scope ü§†"
  },
  {
    "objectID": "courses/3501.6.html#texturas",
    "href": "courses/3501.6.html#texturas",
    "title": "Auxiliar 6",
    "section": "Texturas",
    "text": "Texturas\n\nUsualmente un model necesita m√°s de un color, para manejar c√≥modamente esto se usan texturas. Eso nos permite manipular con precisi√≥n el color de cada parte de nuestro modelo."
  },
  {
    "objectID": "courses/3501.6.html#mapping",
    "href": "courses/3501.6.html#mapping",
    "title": "Auxiliar 6",
    "section": "Mapping",
    "text": "Mapping\n\nAl trabajar con texturas se debe considerar el mapping de estas al modelo. Para ello se hace uso de una la funci√≥n:\n\n\n\\[ f(x,y,z) \\rightarrow (u,v) \\]\n\n\n\nNo suele ser sencillo tener un \\(f\\) definido.\nEs m√°s conveniente escribir las coordenadas de texturas \\((u,v)\\) en cada v√©rtice.\nLuego el valor se interpola antes de llegar al fragment shader."
  },
  {
    "objectID": "courses/3501.6.html#mapping-1",
    "href": "courses/3501.6.html#mapping-1",
    "title": "Auxiliar 6",
    "section": "Mapping",
    "text": "Mapping"
  },
  {
    "objectID": "courses/3501.6.html#en-opengl",
    "href": "courses/3501.6.html#en-opengl",
    "title": "Auxiliar 6",
    "section": "En OpenGL",
    "text": "En OpenGL\nPara crear texturas hacemos lo siguiente:\n\nglGenTextures(1, &texture);\nglBindTexture(GL_TEXTURE_2D, texture); \n// que pasa si las coordenadas son mayores a 1\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   \nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n// como colorear o samplear si la imagen es m√°s grande o m√°s peque√±a que la original\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n// cargar la imagen a la textura\nunsigned char *data = image_load(...);\nif (data) {\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);\n    glGenerateMipmap(GL_TEXTURE_2D);\n}\nimage_free(data);\n\n\nCada vez que queramos usarla debemos vincularla:\n// indice de la textura (se pueden usar m√°s de una a la vez)\nglActiveTexture(GL_TEXTURE0);\nglBindTexture(GL_TEXTURE_2D, texture);"
  },
  {
    "objectID": "courses/3501.6.html#en-el-curso",
    "href": "courses/3501.6.html#en-el-curso",
    "title": "Auxiliar 6",
    "section": "En el curso",
    "text": "En el curso\nPara el curso tenemos la librer√≠a grafica o utils que contiene la clase Texture dentro de drawables.py:\n\nclass Texture():\n    def __init__(self, path=None, image=None, sWrapMode=GL_CLAMP_TO_EDGE, \n                 tWrapMode=GL_CLAMP_TO_EDGE, minFilterMode=GL_LINEAR, \n                 maxFilterMode=GL_LINEAR, flip_top_bottom=True):\n        ...\n\n        texture = glGenTextures(1)\n        glBindTexture(GL_TEXTURE_2D, texture)\n\n        # texture wrapping params\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, sWrapMode)\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, tWrapMode)\n\n        # texture filtering params\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilterMode)\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, maxFilterMode)\n\n        # loading image\n        ...\n\n        glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, image.size[0],\n                     image.size[1], 0, format, GL_UNSIGNED_BYTE, img_data)\n\n\nEsta clase funciona autom√°ticamente con el grafo de escena de la librer√≠a, no es necesario vincularla."
  },
  {
    "objectID": "courses/3501.6.html#otros-usos",
    "href": "courses/3501.6.html#otros-usos",
    "title": "Auxiliar 6",
    "section": "Otros usos",
    "text": "Otros usos\n\nNo es necesario guardar solamente los colores en las texturas, se pueden guardar:\n\n\n\nNormales\nDesplazamiento\nAltura\nLiteralmente cualquier cosa\n\n\n\nTambi√©n se puede escribir a una textura, esto permite hacerle post-procesado a cada frame, las sombras se crean de esta forma."
  },
  {
    "objectID": "courses/3501.6.html#iluminaci√≥n",
    "href": "courses/3501.6.html#iluminaci√≥n",
    "title": "Auxiliar 6",
    "section": "Iluminaci√≥n",
    "text": "Iluminaci√≥n\n\nLa clave de una escena realista reside en la iluminaci√≥n. Para modelarla existe la ecuaci√≥n de rendering:\n\n\n\\[ L_{\\text{o}}(\\mathbf x, \\omega_{\\text{o}}, \\lambda, t) = L_{\\text{e}}(\\mathbf x, \\omega_{\\text{o}}, \\lambda, t) + L_{\\text{r}}(\\mathbf x, \\omega_{\\text{o}}, \\lambda, t)\\]\n\n\n\\[L_{\\text{r}}(\\mathbf x, \\omega_{\\text{o}}, \\lambda, t) = \\int_\\Omega f_{\\text{r}}(\\mathbf x, \\omega_{\\text{i}}, \\omega_{\\text{o}}, \\lambda, t) L_{\\text{i}}(\\mathbf x, \\omega_{\\text{i}}, \\lambda, t) (\\omega_{\\text{i}}\\cdot\\mathbf n) \\operatorname d \\omega_{\\text{i}}\\]"
  },
  {
    "objectID": "courses/3501.6.html#shading",
    "href": "courses/3501.6.html#shading",
    "title": "Auxiliar 6",
    "section": "Shading",
    "text": "Shading\n\nComo es muy complejo resolver la ecuaci√≥n, se usan aproximaciones:\n\n\n\nFlat shading\nGourat shading\nPhong shading\nDeferred shading"
  },
  {
    "objectID": "courses/3501.6.html#shading-1",
    "href": "courses/3501.6.html#shading-1",
    "title": "Auxiliar 6",
    "section": "Shading",
    "text": "Shading\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEn otra ocasi√≥n veremos en detalle el modelo de Phong"
  },
  {
    "objectID": "courses/3501.6.html#p1-texturas",
    "href": "courses/3501.6.html#p1-texturas",
    "title": "Auxiliar 6",
    "section": "P1 ‚Äî Texturas",
    "text": "P1 ‚Äî Texturas\n\n\nParte A\nCargue a su escena un modelo externo que contenga multiples partes y texturas\n\n\n\nParte B\nA√±adamos un Billboard, para ello agregue a la escena un quad que le permita cargar cualquier textura. Luego aplique adecuadamente transformaciones para que el quad quede siempre mirando a la c√°mara."
  },
  {
    "objectID": "courses/3501.6.html#p1-texturas-1",
    "href": "courses/3501.6.html#p1-texturas-1",
    "title": "Auxiliar 6",
    "section": "P1 ‚Äî Texturas",
    "text": "P1 ‚Äî Texturas\nParte C\n\nSubamos el nivel con el uso de texturas, revise el archivo atlas.png, encuentre una forma de a√±adir a su escena un cubo capaz de cargar cualquier textura disponible en el atlas.\n\n\n\n\n\n\n\n\n\nPara ello cree la funci√≥n get_atalas_uv(x,y), que le retorne las coordenadas de texturas correspondiente al quad con coordenadas \\((x,y)\\) en el atlas."
  },
  {
    "objectID": "courses/3501.6.html#p2-iluminaci√≥n",
    "href": "courses/3501.6.html#p2-iluminaci√≥n",
    "title": "Auxiliar 6",
    "section": "P2 ‚Äî Iluminaci√≥n",
    "text": "P2 ‚Äî Iluminaci√≥n\n\n\nParte A\nA√±ada iluminaci√≥n realista a su escena, para ello modifique su shader para que soporte luces. Para un efecto adecuado, debe incluir las normales de sus modelos.\n\n\n\nParte B\nCree un nuevo pipeline para poder vincular su luz con un modelo en la escena. Esto se puede conseguir manteniendo un shader que no procesa iluminaci√≥n y us√°ndolo en el nuevo pipeline.\n\n\n\nParte C\nVincule la posici√≥n de la luz con la c√°mara y a√±ada uniforms a su shader de iluminaci√≥n para que pueda mover la iluminaci√≥n en tiempo real. Puede agregar controles extras para mejorar la manipulaci√≥n de la luz."
  },
  {
    "objectID": "courses/3501.8.html#modelo-de-phong",
    "href": "courses/3501.8.html#modelo-de-phong",
    "title": "Auxiliar 8",
    "section": "Modelo de Phong",
    "text": "Modelo de Phong\n\n\nEs un modelo de iluminaci√≥n local.\nNo es costoso y es muy paralelizable.\nUsa los conceptos de Materiales y Luces."
  },
  {
    "objectID": "courses/3501.8.html#materiales",
    "href": "courses/3501.8.html#materiales",
    "title": "Auxiliar 8",
    "section": "Materiales",
    "text": "Materiales\n\nDefinimos un material como:\n\\[(\\mathcal{K}_a, \\mathcal{K}_d, \\mathcal{K}_s, \\alpha)\\]\n\n\n\n\\(\\mathcal{K}_a\\) - color ambiental del modelo (sin luz).\n\\(\\mathcal{K}_d\\) - color difuso del modelo (con luz).\n\\(\\mathcal{K}_s\\) - color especular del modelo (con reflejos).\n\\(\\alpha\\) - brillo o shininess del modelo (forma de los reflejos)."
  },
  {
    "objectID": "courses/3501.8.html#materiales-1",
    "href": "courses/3501.8.html#materiales-1",
    "title": "Auxiliar 8",
    "section": "Materiales",
    "text": "Materiales\n\n\nTexturas\n\n\nCon texturas se suele tener texturas adicionales que guardan los valores difusos y especulares\n\n\n\n\n\n\n\n\n\n\n\nDifuso\n\n\n\n\n\n\n\nEspecular"
  },
  {
    "objectID": "courses/3501.8.html#luces",
    "href": "courses/3501.8.html#luces",
    "title": "Auxiliar 8",
    "section": "Luces",
    "text": "Luces\n\n\\[\n\\mathcal{I} = \\frac{\\mathcal{K}_a \\mathcal{L}_a + \\mathcal{K}_d \\mathcal{L}_d (l \\cdot n) + \\mathcal{K}_s \\mathcal{L}_s (v \\cdot r)^{\\alpha} }{k_c + k_l d + k_q d^2}\n\\]\n\n\n\n\\((\\mathcal{K}_a, \\mathcal{K}_d, \\mathcal{K}_s, \\alpha)\\) ‚Äî par√°metros del material\n\\((\\mathcal{L}_a, \\mathcal{L}_d, \\mathcal{L}_s)\\) ‚Äî par√°metros del color de la luz\n\\((k_c, k_l, k_q)\\) ‚Äî par√°metros del atenuaci√≥n de la luz\n\\(n\\) ‚Äî normal de la superficie\n\\(l\\) ‚Äî direcci√≥n hacia la fuente de luz\n\\(v\\) ‚Äî direcci√≥n hacia la c√°mara\n\\(r\\) ‚Äî reflexi√≥n sobre la superficie\n\\(d\\) ‚Äî distancia a la fuente de luz"
  },
  {
    "objectID": "courses/3501.8.html#luces-1",
    "href": "courses/3501.8.html#luces-1",
    "title": "Auxiliar 8",
    "section": "Luces",
    "text": "Luces\nDireccional\n\n\n\n\nRepresenta una luz lejana\nMantiene la misma direcci√≥n\n\n\n\n\n\\[(\\mathcal{L}_a, \\mathcal{L}_d, \\mathcal{L}_s, l)\\]"
  },
  {
    "objectID": "courses/3501.8.html#luces-2",
    "href": "courses/3501.8.html#luces-2",
    "title": "Auxiliar 8",
    "section": "Luces",
    "text": "Luces\nLuz puntual\n\n\n\n\nLa luz b√°sica\nSe aten√∫a con la distancia\n\n\n\n\n\\[(\\mathcal{L}_a, \\mathcal{L}_d, \\mathcal{L}_s, k_c, k_l, k_q)\\]"
  },
  {
    "objectID": "courses/3501.8.html#luces-3",
    "href": "courses/3501.8.html#luces-3",
    "title": "Auxiliar 8",
    "section": "Luces",
    "text": "Luces\nSpotlight\n\n\n\n\nEs como una linterna\nTiene un foco principal\nDeterminado por un \\(\\theta\\) y \\(\\theta_{outer}\\)\n\n\n\n\n\\[(\\mathcal{L}_a, \\mathcal{L}_d, \\mathcal{L}_s, k_c, k_l, k_q, l, \\theta, \\theta_{outer})\\]"
  },
  {
    "objectID": "courses/3501.8.html#p2-shading",
    "href": "courses/3501.8.html#p2-shading",
    "title": "Auxiliar 8",
    "section": "P2 ‚Äì Shading",
    "text": "P2 ‚Äì Shading\n\n\nParte A\nCree un nuevo shader donde incluya luces y materiales, para ello puede utilizar\n\n\n\nParte B\nCree 3 funciones para calcular el color seg√∫n cada tipo de fuente de luz.\n\n\n\nParte C\nA√±ada al shader una funci√≥n que calcule el color final del pixel seg√∫n la iluminaci√≥n de la escena."
  },
  {
    "objectID": "courses/3501.8.html#p1-en-escena",
    "href": "courses/3501.8.html#p1-en-escena",
    "title": "Auxiliar 8",
    "section": "P1 ‚Äî En escena",
    "text": "P1 ‚Äî En escena\nUsando la escena de clase pasada y sus nuevos shaders\n\n\nParte A\nCree 3 bloques nuevos que est√©n hechos de distintos materiales. A√±ada tambi√©n un piso de material simple (sin textura).\n\n\n\nParte B\nCree 2 luces puntuales que roten alrededor de la escena, a√±ada un modelo para representar la ubicaci√≥n de estas luces.\n\n\n\nParte C\nHaga un ciclo de dia y noche, para ello cree una luz direccional que se mueva con el tiempo. Adem√°s, cree una linterna para la c√°mara usando una luz spotlight para la noche.\nUtilice diversos pipelines para corregir los errores de iluminaci√≥n."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Inicio",
    "section": "",
    "text": "Bienvenido üòÉ"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "courses/4302.8.html#spinlocks",
    "href": "courses/4302.8.html#spinlocks",
    "title": "Auxiliar 8",
    "section": "Spinlocks",
    "text": "Spinlocks\n\n\nHerramienta de sincronizaci√≥n primitiva\nNo depende de un sistema operativo\nIgual de potente que el resto!\n\n\n\n\nCreaci√≥n\nint sl = OPEN; // o CLOSED\n\n\n\nBloqueo\nspinLock(&sl); \n\n\n\nDesbloqueo\nspinUnlock(&sl);"
  },
  {
    "objectID": "courses/4302.8.html#how-to",
    "href": "courses/4302.8.html#how-to",
    "title": "Auxiliar 8",
    "section": "How to?",
    "text": "How to?\n\n\n\n\nMutex\nint sl = OPEN; // global\n\n// ...\n\nvoid fun() {\n  spinLock(&sl);\n\n  // secci√≥n cr√≠tica\n\n  spinUnlock(&sl);\n}\n\n\n\n\nCondici√≥n\nint *psl; // global\n\n// ...\n\nvoid f() {\n  // thread que espera\n  int sl = CLOSED;\n  psl = &sl;\n\n  spinLock(&sl); // espera\n  // ...\n}\n\nvoid g() {\n  // thread que despierta\n  spinUnlock(psl); // despierta\n}"
  },
  {
    "objectID": "courses/4302.8.html#implementaci√≥n",
    "href": "courses/4302.8.html#implementaci√≥n",
    "title": "Auxiliar 8",
    "section": "Implementaci√≥n",
    "text": "Implementaci√≥n\nvoid spinLock(volatile int *psl) {\n  do {\n    while (*psl == CLOSED)\n      ;\n  } while (swap(psl, CLOSED) != OPEN);\n}"
  },
  {
    "objectID": "courses/4302.8.html#p1-lectorescritor",
    "href": "courses/4302.8.html#p1-lectorescritor",
    "title": "Auxiliar 8",
    "section": "P1 ‚Äî Lector/escritor",
    "text": "P1 ‚Äî Lector/escritor\n\n\nParte A\nLa siguiente implementaci√≥n es incorrecta. Haga un diagrama de threads que muestre que un lector puede entrar junto con un escritor.\n\n\nvoid enterRead() {\n  if (readers == 0)\n    spinLock(&write_lck);\n  spinLock(&mutex_lck);\n  readers++;\n  spinUnlock(&mutex_lck);\n}\n\nvoid enterWrite() {\n  spinLock(&write_lck);\n}\n\nvoid exitRead() {\n  spinLock(&mutex_lck);\n  readers--;\n  spinUnlock(&mutex_lck);\n\n  if (readers == 0)\n    spinUnlock(&write_lck);\n}\n\nvoid exitWrite() {\n  spinUnlock(&write_lck);\n}\n\n\n\n\nParte B\nModifique la soluci√≥n anterior para que funcione correctamente."
  },
  {
    "objectID": "courses/4302.8.html#p2-funci√≥n-team",
    "href": "courses/4302.8.html#p2-funci√≥n-team",
    "title": "Auxiliar 8",
    "section": "P2 ‚Äî Funci√≥n team",
    "text": "P2 ‚Äî Funci√≥n team\nConsidere una m√°quina multicore en la que no existe un n√∫cleo de sistema operativo y por lo tanto no hay un scheduler de procesos.\nSe necesita formar m√∫ltiple equipos de 5 cores cada uno. Para ello, los cores invocan la funci√≥n team indicando su nombre como argumento. Esta funci√≥n espera hasta que 5 cores hayan invocado team, retornando un arreglo de 5 strings con los nombres del equipo completo.\nEste es un ejemplo del uso de la funci√≥n team:\nint player(char *name) {\n  for (;;) {\n    char **mTeam = team(name);\n    play(mTeam);\n    sleep();\n  }\n}"
  },
  {
    "objectID": "courses/4302.8.html#p2-funci√≥n-team-1",
    "href": "courses/4302.8.html#p2-funci√≥n-team-1",
    "title": "Auxiliar 8",
    "section": "P2 ‚Äî Funci√≥n team",
    "text": "P2 ‚Äî Funci√≥n team\nSe debe programar la funci√≥n team con el siguiente encabezado:\nchar **team(char *name);\nSe dispone de spin-locks y la funci√≥n coreId(). Necesitar√° usar variables globales y malloc.\nRestricci√≥n: Dado que no hay un n√∫cleo de sistema operativo, la √∫nica forma v√°lida de esperar a que se forme el equipo es utilizando un spin-lock. Otras formas de busy-waiting no est√°n permitidas. No hay Queues FIFO."
  },
  {
    "objectID": "courses/4302.8.html#p3-propuesto",
    "href": "courses/4302.8.html#p3-propuesto",
    "title": "Auxiliar 8",
    "section": "P3 ‚Äì Propuesto",
    "text": "P3 ‚Äì Propuesto\n\nConsidere una m√°quina con 8 cores f√≠sicos que comparten la memoria, sin un n√∫cleo de sistema operativo y por lo tanto no hay scheduler de procesos. A cada core se le asignan inicialmente 100 euros.\nUn core puede robar cantidad euros del core n√∫mero desde invocando la funci√≥n:\nvoid robar(int desde, int cantidad);\nEn tal caso se le resta cantidad euros a la tarea desde y se le suman al core que invoc√≥ robar. El par√°metro cantidad es siempre mayor que cero.\nUn primer invariante es que un core no puede almacenar una cantidad negativa de euros. Si el core desde no posee suficiente dinero para robarle cantidad entonces robar debe esperar hasta que el core desde s√≠ posea al menos la cantidad requerida.\nEl segundo invariante es que en un instante dado el core \\(T\\) no puede estar esperando robarle \\(c\\) euros al core \\(U\\) si \\(U\\) tiene al menos \\(c\\) euros. Observe que cuando el core \\(T\\) lograr robar dinero, varios otros cores pueden estar esperando poder robarle dinero a \\(T\\). No est√° especificado en qu√© orden deben robarle el dinero a \\(T\\).\nAyuda\nUse una matriz m de 8 por 8 punteros a spin-locks. Si m[i][j] no es nulo quiere decir que m[i][j] es la direcci√≥n de un spin-lock en el que el core i espera para robarle al core j.\n\n\n\nSacado del C2 de Oto√±o 2017"
  },
  {
    "objectID": "courses/4302.8.html#p3-propuesto-1",
    "href": "courses/4302.8.html#p3-propuesto-1",
    "title": "Auxiliar 8",
    "section": "P3 ‚Äì Propuesto",
    "text": "P3 ‚Äì Propuesto\nEl siguiente diagrama muestra una situaci√≥n con 5 threads:\n\n\n\nSacado del C2 de Oto√±o 2017"
  },
  {
    "objectID": "courses/4302.4.html#sem√°foros",
    "href": "courses/4302.4.html#sem√°foros",
    "title": "Auxiliar 4",
    "section": "Sem√°foros",
    "text": "Sem√°foros\n\n\nOtra herramienta de sincronizaci√≥n\nM√°s simple que mutex con condiciones\nIgual de potente\nFunciona como un sistema de tickets o fichas\nLos procesos puede solicitar fichas o depositarlas\n\n\n\nSi no hay fichas, los procesos que soliciten deben esperar a que se deposite"
  },
  {
    "objectID": "courses/4302.4.html#manejo",
    "href": "courses/4302.4.html#manejo",
    "title": "Auxiliar 4",
    "section": "Manejo",
    "text": "Manejo\nInicializaci√≥n\n\nPara crear\nvoid sem_init(sem_t *sem, int pshared, unsigned int val);\n\n\nsem: Puntero al sem√°foro a inicializar.\npshared: Flag para indicar si el sem√°foro ser√° compartido entre threads (0) o entre procesos (1).\nval: Cantidad de fichas iniciales\n\n\n\n\nPara destruir\nvoid sem_destroy(sem_t *sem);\n\n\nsem: Puntero al sem√°foro a destruir."
  },
  {
    "objectID": "courses/4302.4.html#manejo-1",
    "href": "courses/4302.4.html#manejo-1",
    "title": "Auxiliar 4",
    "section": "Manejo",
    "text": "Manejo\nUso\n\nPara extraer una ficha:\nvoid sem_wait(sem_t *sem); \n\n\nPara depositar una ficha:\nvoid sem_post(sem_t *sem); \nAl igual que con los mutex, no esta garantizado el orden de adquisici√≥n"
  },
  {
    "objectID": "courses/4302.4.html#comportamiento",
    "href": "courses/4302.4.html#comportamiento",
    "title": "Auxiliar 4",
    "section": "Comportamiento",
    "text": "Comportamiento\n\nLos sem√°foros se pueden usar como mutex o condiciones.\n\n\n\n\nMutex\nCon una √∫nica ficha\nsem_t sem;\nsem_init(&sem, 0, 1);\nPara entrar a la zona cr√≠tica un thread solicita la ficha y al salir lo deposita\n\n\nCondiciones\nSin fichas\nsem_t sem;\nsem_init(&sem, 0, 0);\nAl llamar sem_wait el proceso debe esperar a un sem_post"
  },
  {
    "objectID": "courses/4302.4.html#ejemplo",
    "href": "courses/4302.4.html#ejemplo",
    "title": "Auxiliar 4",
    "section": "Ejemplo",
    "text": "Ejemplo\n...\nsem_wait(&sem); \nif (se_debe_esperar) {\n    sem_post(&sem); \n    sem_wait(&wait); \n    sem_wait(&sem); \n}\nsem_post(&sem); \n...\n\n\nsem act√∫a como mutex\nwait act√∫a como condici√≥n"
  },
  {
    "objectID": "courses/4302.4.html#ejemplo-1",
    "href": "courses/4302.4.html#ejemplo-1",
    "title": "Auxiliar 4",
    "section": "Ejemplo",
    "text": "Ejemplo\n...\nsem_wait(&sem); \nif (se_debe_esperar) {\n    sem_post(&sem); \n    sem_wait(&wait); \n    sem_wait(&sem); \n}\nsem_post(&sem); \n...\nPedir el mutex al entrar y salir de la zona cr√≠tica"
  },
  {
    "objectID": "courses/4302.4.html#ejemplo-2",
    "href": "courses/4302.4.html#ejemplo-2",
    "title": "Auxiliar 4",
    "section": "Ejemplo",
    "text": "Ejemplo\n...\nsem_wait(&sem); \nif (se_debe_esperar) {\n    sem_post(&sem); \n    sem_wait(&wait); \n    sem_wait(&sem); \n}\nsem_post(&sem); \n...\nEsperar a que la condici√≥n se cumpla (sin while)"
  },
  {
    "objectID": "courses/4302.4.html#ejemplo-3",
    "href": "courses/4302.4.html#ejemplo-3",
    "title": "Auxiliar 4",
    "section": "Ejemplo",
    "text": "Ejemplo\n...\nsem_wait(&sem); \nif (se_debe_esperar) {\n    sem_post(&sem); \n    sem_wait(&wait); \n    sem_wait(&sem); \n}\nsem_post(&sem); \n...\nOJO\nHay que liberar el mutex antes de esperar y pedirlo despu√©s"
  },
  {
    "objectID": "courses/4302.4.html#p1-ba√±o-compartido",
    "href": "courses/4302.4.html#p1-ba√±o-compartido",
    "title": "Auxiliar 4",
    "section": "P1 ‚Äì Ba√±o compartido",
    "text": "P1 ‚Äì Ba√±o compartido\n\nUn estadio posee un √∫nico ba√±o que debe ser compartido por hinchas rojos y azules. El ba√±o es amplio y admite un n√∫mero ilimitado de personas. El problema consiste en evitar que los hinchas rojos se encuentren con los hinchas azules dentro del ba√±o.\n\n\nLos hinchas rojos solicitan entrar al ba√±o invocando entrar(ROJO) y notifican su salida con salir(ROJO), mientras que los hinchas azules invocan entrar(AZUL) y salir(AZUL)."
  },
  {
    "objectID": "courses/4302.4.html#p1-ba√±o-compartido-1",
    "href": "courses/4302.4.html#p1-ba√±o-compartido-1",
    "title": "Auxiliar 4",
    "section": "P1 ‚Äì Ba√±o compartido",
    "text": "P1 ‚Äì Ba√±o compartido\nParte A\nSe plantea la siguiente soluci√≥n incorrecta para el problema:\n\n\nenum { ROJO = 0, AZUL =  1};\n\nint cantidad[2] = {0, 0};\n\n// Este mutex representa \n// el acceso al ba√±o, el\n// equipo que lo tiene \n// es el que est√° adentro\nint mutex = 0; \n\nvoid entrar(int color) {\n  if (cantidad[color] == 0) {\n    while(mutex)\n      ;\n    mutex = 1;\n  }\n  cantidad[color]++;\n}\n\nvoid salir(int color) {\n  cantidad[color]--;\n  if (cantidad[color] == 0) {\n    mutex = 0;\n  }\n}\n\nMuestre mediante un diagrama de threads que un hincha rojo puede entrar al ba√±o cuando hay hinchas azules presentes"
  },
  {
    "objectID": "courses/4302.4.html#p1-ba√±o-compartido-2",
    "href": "courses/4302.4.html#p1-ba√±o-compartido-2",
    "title": "Auxiliar 4",
    "section": "P1 ‚Äì Ba√±o compartido",
    "text": "P1 ‚Äì Ba√±o compartido\nParte B\nEscriba una soluci√≥n correcta y eficiente para este problema utilizando 3 sem√°foros. No importa si en su soluci√≥n algunos procesos sufren ‚Äúhambruna‚Äù\n\n\nCorrecta\n\nNo hay datarraces\n\nEficiente\n\nNo hay busy waiting\n\n\n\n\n\nHint: Utilice la estructura de la soluci√≥n incorrecta"
  },
  {
    "objectID": "courses/4302.4.html#p2-ba√±o-sin-hambruna",
    "href": "courses/4302.4.html#p2-ba√±o-sin-hambruna",
    "title": "Auxiliar 4",
    "section": "P2 ‚Äì Ba√±o sin hambruna",
    "text": "P2 ‚Äì Ba√±o sin hambruna\n\nConsidere ahora una soluci√≥n en la que no se produzca hambruna. Para lograr esto es necesario que ning√∫n hincha entre al ba√±o mientras haya hinchas del otro equipo esperando. Luego, cuando sale el √∫ltimo hincha del ba√±o, entran todos los hinchas del equipo contrario que estaban esperando. Por ejemplo, si hay dos hinchas del equipo rojo en el ba√±o y un hincha azul en espera, el siguiente hincha rojo en llegar no podr√° entrar hasta que haya entrado (y salido) el azul.\n\n\n\nParte A\nSe incluye una implementaci√≥n incorrecta de esta soluci√≥n. Demuestra que esta soluci√≥n es incorrecta confeccionando un diagrama de threads donde la exclusi√≥n mutua no se cumple.\n\n\n\nEsta parte fue adaptada de la tarea 1 del semestre 2021-1"
  },
  {
    "objectID": "courses/4302.4.html#p2-ba√±o-sin-hambruna-1",
    "href": "courses/4302.4.html#p2-ba√±o-sin-hambruna-1",
    "title": "Auxiliar 4",
    "section": "P2 ‚Äì Ba√±o sin hambruna",
    "text": "P2 ‚Äì Ba√±o sin hambruna\nParte A\n\n\n// Un sem√°foro controla el acceso\n// a la zona cr√≠tica.\nsem_t mutex; \n// Un sem√°foro para la \n// espera cada tipo de hincha. \nsem_t sem[2]; \nint esperan[2] = {0, 0}; \nint adentro[2] = {0, 0};\n\nvoid entrar(int color){\n  // el oponente del equipo AZUL \n  // es el equipo ROJO y viceversa.\n  int oponente = !color ;\n  sem_wait(&mutex);\n    // Si hay hinchas del otro equipo \n    // en el ba√±o o en la cola \n    // se debe esperar.\n    if (adentro[oponente] &gt; 0 ||\n        esperan[oponente] &gt; 0){ \n      esperan[color]++;\n      sem_post(&mutex);\n      // se pone el thread en espera \n      sem_wait(&sem[color]); \n      sem_wait(&mutex);\n    }\n    adentro[color]++; // entramos al ba√±o\n    sem_post(&mutex); \n}\n\nvoid salir(int color) {\n  int oponente = !color; \n  sem_wait(&mutex);\n  adentro[color]--; // salimos del ba√±o\n\n  if (adentro[color] == 0) {\n    // Despertar a los oponentes poniendo \n    // tantos tickets como son \n    // threads hay en espera\n    for (int i = 0; i &lt; esperan[oponente]; i++) {\n      sem_post(&sem[oponente ]); \n    }\n    esperan[oponente] = 0;\n  }\n  sem_wait(&mutex );\n}"
  },
  {
    "objectID": "courses/4302.4.html#p2-ba√±o-sin-hambruna-2",
    "href": "courses/4302.4.html#p2-ba√±o-sin-hambruna-2",
    "title": "Auxiliar 4",
    "section": "P2 ‚Äì Ba√±o sin hambruna",
    "text": "P2 ‚Äì Ba√±o sin hambruna\nParte A\n\n\nLa mayor√≠a de estos dataraces ocurren en el momento de despertar los threads en espera, en ese instante un thread extra se puede escabullir en la zona cr√≠tica (si se cumplen las condiciones para que entre y se roba el mutex). Este thread puede cambiar las variables compartidas y alterar la correctitud del programa.\nDebemos garantizar la correctitud del programa sin importar que un thread extra se robe el mutex, o debemos garantizar que nunca un thread extra pueda escabullirse.\nEn general esto se soluciona cambiando todas las variables compartidas en el thread que despierta a los dem√°s, los thread en espera se despiertan y solo deben retornar."
  },
  {
    "objectID": "courses/4302.4.html#p2-ba√±o-sin-hambruna-3",
    "href": "courses/4302.4.html#p2-ba√±o-sin-hambruna-3",
    "title": "Auxiliar 4",
    "section": "P2 ‚Äì Ba√±o sin hambruna",
    "text": "P2 ‚Äì Ba√±o sin hambruna\nParte B\nReprograme la soluci√≥n anterior de modo que siempre funcione correctamente. Utilice la siguiente metodolog√≠a:\n\nUtilice 2 colas FIFO globales, una para cada equipo.\nCuando un hincha deba esperar para entrar al ba√±o, cree un sem√°foro con 0 tickets y p√≥ngalo en la cola correspondiente. Luego, suspenda el thread solicitando un ticket a este sem√°foro.\nCuando salga el ultimo hincha de un equipo y haya hinchas del otro en espera, extraiga todos los sem√°foros de esa cola y deposite en cada uno de ellos un ticket para permitirle a los hinchas en espera entrar al ba√±o.\nUtilice un sem√°foro para garantizar exclusi√≥n mutua en el acceso a las variables globales."
  },
  {
    "objectID": "courses/3501.2.html#la-escena",
    "href": "courses/3501.2.html#la-escena",
    "title": "Auxiliar 2",
    "section": "La escena",
    "text": "La escena\n\n\nObjetos\n\nSon los actores de la escena\nManejar geometr√≠a, transformaciones, texturas, material y f√≠sica\n\nC√°mara\n\nSon los ojos por los que se ve la escena\nManejar posici√≥n y perspectiva\n\nLuces\n\nSon lo que le da color a la escena\nManejar posici√≥n, tipo de fuente, intensidad, sombras"
  },
  {
    "objectID": "courses/3501.2.html#la-escena-1",
    "href": "courses/3501.2.html#la-escena-1",
    "title": "Auxiliar 2",
    "section": "La escena",
    "text": "La escena"
  },
  {
    "objectID": "courses/3501.2.html#pipeline",
    "href": "courses/3501.2.html#pipeline",
    "title": "Auxiliar 2",
    "section": "Pipeline",
    "text": "Pipeline\n\n\n\n\nUna serie de pasos para obtener la imagen\nProceso complejo que involucra muchos c√°lculos\nSe puede alterar en ciertas etapas\n\nVertex Shader\nTesellation\nGeometry Shader\nFragment Shader"
  },
  {
    "objectID": "courses/3501.2.html#pipeline-1",
    "href": "courses/3501.2.html#pipeline-1",
    "title": "Auxiliar 2",
    "section": "Pipeline",
    "text": "Pipeline\n\n\n\nUna serie de pasos para obtener la imagen\nProceso complejo que involucra muchos c√°lculos\nSe puede alterar en ciertas etapas\n\nVertex Shader\nTesellation\nGeometry Shader\nFragment Shader"
  },
  {
    "objectID": "courses/3501.2.html#pipeline-2",
    "href": "courses/3501.2.html#pipeline-2",
    "title": "Auxiliar 2",
    "section": "Pipeline",
    "text": "Pipeline\nSe resume a lo siguiente:\n\n\nVertex shading: Colorear cada v√©rtice\nProjection: Proyectar los v√©rtices en la escena\nClipping: Ajustar la geometr√≠a seg√∫n lo que se ve en realidad\nScreen Mapping: Pasar de coordenadas uniformes a las coordenadas de la pantalla\nRasterization: Discretizar la imagen\nPixel processing: Colorear / procesar cada p√≠xel"
  },
  {
    "objectID": "courses/3501.2.html#shaders",
    "href": "courses/3501.2.html#shaders",
    "title": "Auxiliar 2",
    "section": "Shaders",
    "text": "Shaders\nVertex Shader\n\n\nSe encarga de definir los v√©rtices desde la memoria\nAct√∫a simult√°neamente en cada v√©rtice\nRecibe como input los datos a utilizar\nDebe definir la posici√≥n del v√©rtice\nPuede pasarle informaci√≥n a los siguientes pasos"
  },
  {
    "objectID": "courses/3501.2.html#shaders-1",
    "href": "courses/3501.2.html#shaders-1",
    "title": "Auxiliar 2",
    "section": "Shaders",
    "text": "Shaders\nFragment Shader\n\n\nSe encarga de definir el color de los p√≠xeles\nAct√∫a simult√°neamente en cada p√≠xel\nDebe definir el color final del p√≠xel\nPuede recibir informaci√≥n a desde los pasos anteriores"
  },
  {
    "objectID": "courses/3501.2.html#p1-generar-un-c√≠rculo",
    "href": "courses/3501.2.html#p1-generar-un-c√≠rculo",
    "title": "Auxiliar 2",
    "section": "P1 ‚Äî Generar un c√≠rculo",
    "text": "P1 ‚Äî Generar un c√≠rculo\nCree la siguiente funci√≥n:\ndef create_circle(x, y, radius) \nLa cual toma:\n\nLa posici√≥n del centro del c√≠rculo\nEl radio del c√≠rculo\n\nY retorna un arreglo con las posiciones de cada v√©rtice para formar el c√≠rculo"
  },
  {
    "objectID": "courses/3501.2.html#p2-a√±adir-color",
    "href": "courses/3501.2.html#p2-a√±adir-color",
    "title": "Auxiliar 2",
    "section": "P2 ‚Äî A√±adir color",
    "text": "P2 ‚Äî A√±adir color\nAhora que tiene su c√≠rculo cambie la funci√≥n anterior para incluir color:\ndef create_circle(x, y, r, g, b, radius) \nDonde \\((r, g, b)\\) son las componentes de color del c√≠rculo y tienen un valor de 0 a 1.\nAhora la funci√≥n debe incluir el color de cada v√©rtice para formar el c√≠rculo\n\n\nPropuesto: Trate de variar un poco el color para cada punto o incluso usar 2 colores"
  },
  {
    "objectID": "courses/3501.2.html#p3-agregar-indices",
    "href": "courses/3501.2.html#p3-agregar-indices",
    "title": "Auxiliar 2",
    "section": "P3 ‚Äî Agregar indices",
    "text": "P3 ‚Äî Agregar indices\nSu funci√≥n actual hace uso de mucha memoria de manera innecesaria, us√© la funci√≥n de Pyglet shader.vertex_list_indexed la cual recibe adicionalmente una lista de √≠ndices los cuales indican que v√©rtices forman un tri√°ngulo.\nPara crear esa lista programe la funci√≥n:\ndef create_circle_indices()"
  },
  {
    "objectID": "courses/3501.2.html#p4-un-poquito-de-movimiento",
    "href": "courses/3501.2.html#p4-un-poquito-de-movimiento",
    "title": "Auxiliar 2",
    "section": "P4 ‚Äî Un poquito de movimiento",
    "text": "P4 ‚Äî Un poquito de movimiento\nAhora que tiene todo listo y bonito, pruebe a√±adir las siguientes animaciones:\n\nUna en la cual el c√≠rculo crece y luego se empeque√±ece\nUna en la cual el se mueve de izquierda a derecha\nUna en la cual hay 2 c√≠rculos bailando (use su imaginaci√≥n)"
  },
  {
    "objectID": "courses/4302.0.html",
    "href": "courses/4302.0.html",
    "title": "Sistemas operativos",
    "section": "",
    "text": "Introducci√≥n a Pthreads\nSincronizaci√≥n de Threads\nSem√°foros\nTimeouts y Prioridades\nSpinlock",
    "crumbs": [
      "Cursos",
      "2024",
      "Sistemas operativos"
    ]
  },
  {
    "objectID": "courses/4302.0.html#auxiliares",
    "href": "courses/4302.0.html#auxiliares",
    "title": "Sistemas operativos",
    "section": "",
    "text": "Introducci√≥n a Pthreads\nSincronizaci√≥n de Threads\nSem√°foros\nTimeouts y Prioridades\nSpinlock",
    "crumbs": [
      "Cursos",
      "2024",
      "Sistemas operativos"
    ]
  },
  {
    "objectID": "courses/4302.2.html#creaci√≥n-de-un-thread",
    "href": "courses/4302.2.html#creaci√≥n-de-un-thread",
    "title": "Auxiliar 2",
    "section": "Creaci√≥n de un thread",
    "text": "Creaci√≥n de un thread\nint pthread_create(pthread_t *thread, \n                   const pthread_attr_t *attr, \n                   void *(*start_routine)(void *), \n                   void *arg);\n\n\nLanza un nuevo thread que ejecuta start_routine.\nstart_routine recibe arg como argumento.\nEl thread se puede crear con atributos attr especiales (NULL).\nEl ‚ÄúID‚Äù del proceso se guarda en thread\nRetorna 0 si la creaci√≥n del proceso fue exitosa"
  },
  {
    "objectID": "courses/4302.2.html#t√©rmino-de-un-thread",
    "href": "courses/4302.2.html#t√©rmino-de-un-thread",
    "title": "Auxiliar 2",
    "section": "T√©rmino de un thread",
    "text": "T√©rmino de un thread\n\nUn thread termina si:\n\n\n\nRetorna start_routine.\nLlamando a pthread_exit (no recomendado).\nint pthread_exit(void *return_value);\n\n\n\nTodo thread cread debe ser enterrado con\nint pthread_join(pthread_t thread, void **return_value);\n\n\n\npthread_join espera a que el thread termine.\n\n\n\nLos thread no enterrados se convierte en zombies y no devuelven los recursos"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo",
    "href": "courses/4302.2.html#ejemplo",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\n#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n\nvoid *thread(void *ptr) {\n  char* nombre = (char*) ptr; // Castear argumento\n  printf(\"Thread - %s\\n\", nombre); // Trabajo en paralelo\n  return NULL; // Retorno\n}\n\nint main() {\n  pthread_t pid_1, pid_2; // Guardar PID de los threads lanzados\n  char* nombre_1 = \"primero\";\n  char* nombre_2 = \"segundo\";\n  pthread_create(&pid_1, NULL, thread, nombre_1); // lanzar thread1\n  pthread_create(&pid_2, NULL, thread, nombre_2); // lanzar thread2\n  pthread_join(pid_1, NULL); // esperar thread 1\n  pthread_join(pid_2, NULL); // esperar thread 2\n  return 0;\n}"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-m√∫ltiples-args",
    "href": "courses/4302.2.html#ejemplo-m√∫ltiples-args",
    "title": "Auxiliar 2",
    "section": "Ejemplo (m√∫ltiples args)",
    "text": "Ejemplo (m√∫ltiples args)\n#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n\ntypedef struct {\n  char* name;\n  int age;\n} Args;\n\nvoid *thread(void *ptr) {\n  Args* a = (Args*) ptr; // Castear a la estructura\n  printf(\"Thread - %s (%d)\\n\", a-&gt;name, a-&gt;age); // Accedemos a los miembros con -&gt;\n  return NULL; // Retorno\n}\n\nint main() {\n  pthread_t pid_1, pid_2; // Guardar PID de los threads lanzados\n  Args a1 = {\"primero\", 10} // inicializamos los args de t1\n  Args a2 = {\"segundo\", 20} // inicializamos los args de t2\n  pthread_create(&pid_1, NULL, thread, &a1); // la pasamos por referencia\n  pthread_create(&pid_2, NULL, thread, &a2); // la pasamos por referencia\n  pthread_join(pid_1, NULL); // esperar thread 1\n  pthread_join(pid_2, NULL); // esperar thread 2\n  return 0;\n}"
  },
  {
    "objectID": "courses/4302.2.html#how-to",
    "href": "courses/4302.2.html#how-to",
    "title": "Auxiliar 2",
    "section": "How to?",
    "text": "How to?\nDise√±o\n\n\nEncontrar las partes paralelizables\nCrear la estructura que permita ingresar los argumentos necesarios\nProgramar la rutina\n\n\n\n\nA veces la rutina s√≥lo ajusta los argumentos para llamar a otra funci√≥n\nEn la estructura de los argumentos podemos guardar cualquier cosa\n\n\n\n\nEsto es no pretende ser una receta, sino que una gu√≠a general"
  },
  {
    "objectID": "courses/4302.2.html#how-to-1",
    "href": "courses/4302.2.html#how-to-1",
    "title": "Auxiliar 2",
    "section": "How to?",
    "text": "How to?\nL√≥gica\n\n\nLanzar los threads con sus argumentos correspondientes\nSi aplica, realizar trabajo en el thread principal\nEsperar a que el trabajo paralelizado termine\nEnterrar los resultados y recolectar los resultados\n\n\n\n\nAntes del join no existe garant√≠a de que el trabajo se haya terminado\nAseg√∫rese de que exista paralelismo entre el create y el join\n\n\n\n\nEsto es no pretende ser una receta, sino que una gu√≠a general"
  },
  {
    "objectID": "courses/4302.2.html#p1-quicksort-paralelo",
    "href": "courses/4302.2.html#p1-quicksort-paralelo",
    "title": "Auxiliar 2",
    "section": "P1 ‚Äî Quicksort paralelo",
    "text": "P1 ‚Äî Quicksort paralelo\nLa siguiente funci√≥n es una implementaci√≥n simple de quicksort:\n#include &lt;pthread.h&gt;\n\nvoid quicksort_seq(int a[], int i, int j) {\n    if (i &lt; j) {\n        int h = particionar(a, i, j);\n        quicksort_seq(a, i, h - 1);\n        quicksort_seq(a. h + 1, j);\n    }\n}\n\n\nConsidere particionar como la funci√≥n que selecciona el pivote y reordena el arreglo.\nLos valores menores al pivote quedan a la izquierda y los mayores a la derecha.\nSe le pide paralelizar la funci√≥n tal que haga uso de \\(N\\) cores:\nvoid quicksort(int a[], int i, int j, int n);\n\n\n\nIdea\nInvocaciones secuenciales independientes son directamente paralelizables"
  },
  {
    "objectID": "courses/4302.2.html#la-nueva-pesadilla",
    "href": "courses/4302.2.html#la-nueva-pesadilla",
    "title": "Auxiliar 2",
    "section": "La nueva pesadilla",
    "text": "La nueva pesadilla\n\nCuando se trabaja en paralelo, nacen nuevos enemigos.\n\n\nAl acceder a recursos compartidos desde varios procesos se pueden generar problemas como:\n\n\n\nDataraces\nVariables se sobreescriben\nRace conditions\nOrden incorrecto de ejecuci√≥n\nHambruna y Deadlocks\nUn proceso no obtiene tiempo de ejecuci√≥n"
  },
  {
    "objectID": "courses/4302.2.html#la-soluci√≥n",
    "href": "courses/4302.2.html#la-soluci√≥n",
    "title": "Auxiliar 2",
    "section": "La soluci√≥n",
    "text": "La soluci√≥n\n\n\nMutex\n\n\n\nMUTual EXclusi√≥n\n\n\nGarantiza la exclusi√≥n mutua, bloqueando el acceso a ‚Äúzonas cr√≠ticas‚Äù, las cuales son zonas del c√≥digo donde se manipulan los recursos compartidos.\n\n\n\n\nCondiciones\n\n\nHacen esperar a los procesos de manera eficiente hasta que se cumpla la condici√≥n para continuar la ejecuci√≥n."
  },
  {
    "objectID": "courses/4302.2.html#manejo",
    "href": "courses/4302.2.html#manejo",
    "title": "Auxiliar 2",
    "section": "Manejo",
    "text": "Manejo\n\n\nInicializaci√≥n\n\n\n\n\nUsando macros\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n\nDentro de una funci√≥n\npthread_mutex_t mutex;\n// ...\npthread_mutex_init(&mutex, NULL);\n\n\n\n\nUso\n\n\nPara solicitar el mutex:\nint pthread_mutex_lock(pthread_mutex_t *mutex); \nLa funci√≥n retorna solo para el primer proceso que pida el mutex, el resto queda esperando\n\n\nPara liberar el mutex:\nint pthread_mutex_unlock(pthread_mutex_t *mutex); \nAl liberar el mutex, todos los procesos se despiertan a la vez, no esta garantizado el orden de adquisici√≥n"
  },
  {
    "objectID": "courses/4302.2.html#comportamiento",
    "href": "courses/4302.2.html#comportamiento",
    "title": "Auxiliar 2",
    "section": "Comportamiento",
    "text": "Comportamiento\n\n\nUn mutex garantiza que s√≥lo un proceso pueda entrar a una su ‚Äúzona cr√≠tica‚Äù de c√≥digo.\nDebe ser solicitado para ingresar y liberado al salir.\nDos estados posibles:\n\n\n\nAbierto\nNing√∫n proceso ha solicitado el mutex\n\nCerrado\nAlg√∫n proceso ha solicitado el mutex y no ha sido liberado\n\n\nSi un proceso intenta solicitar un mutex cerrado, este ser√° suspendido hasta que el mutex sea liberado."
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-1",
    "href": "courses/4302.2.html#ejemplo-1",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\nint contador = 0;\nvoid aumentar_cont() {\n  contador++;\n}\n\nMala implementaci√≥n ü§¢\n\n\n\n¬øD√≥nde esta el error?\n\n\nHagamos un diagrama"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-2",
    "href": "courses/4302.2.html#ejemplo-2",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\npthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;\nint contador = 0;\nvoid aumentar_cont() {\n  pthread_mutex_lock(&m);\n  contador++;\n  pthread_mutex_unlock(&m);\n}\n\nBuena implementaci√≥n ü§†\n\n\n\nRepitamos el diagrama"
  },
  {
    "objectID": "courses/4302.2.html#motivaci√≥n",
    "href": "courses/4302.2.html#motivaci√≥n",
    "title": "Auxiliar 2",
    "section": "Motivaci√≥n",
    "text": "Motivaci√≥n\n\nUna forma de esperar podr√≠a ser:\nwhile (ocupado) {\n    ; // wait\n}\n\n\nEsto es mala idea porque mantiene ocupado al core\n\n\nEs mejor ‚Äúdormir‚Äù el proceso para desocupar el core"
  },
  {
    "objectID": "courses/4302.2.html#manejo-1",
    "href": "courses/4302.2.html#manejo-1",
    "title": "Auxiliar 2",
    "section": "Manejo",
    "text": "Manejo\n\n\nInicializaci√≥n\n\n\n\n\nUsando macros\npthread_cond_t mutex = PTHREAD_COND_INITIALIZER;\n\nDentro de una funci√≥n\npthread_cond_t cond;\n// ...\npthread_cond_init(&cond, NULL);\n\n\n\n\nUso\n\n\nPara hacer esperar a un proceso:\nint pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex); \nAl entrar en espera, el proceso liberar√° el mutex\nAl salir de espera, el proceso esperar√° el mutex y la funci√≥n retornar√° cuando lo obtenga\n\n\nPara despertar procesos:\nint pthread_cond_broadcast(pthread_cond_t *cond); // despertar a todos\nint pthread_cond_signal(pthread_cond_t *cond); // despertar uno (cualquiera)"
  },
  {
    "objectID": "courses/4302.2.html#comportamiento-1",
    "href": "courses/4302.2.html#comportamiento-1",
    "title": "Auxiliar 2",
    "section": "Comportamiento",
    "text": "Comportamiento\n\n\nLa espera es eficiente, dejando disponible el core.\nLa funci√≥n wait se hace cargo de liberar y pedir el mutex asociado.\nLa funci√≥n broadcast despierta a todos los procesos en espera.\nLa funci√≥n signal despierta a un solo proceso sin orden garantizado.\nUn proceso que esperaba por una condici√≥n puede quedar en espera por un mutex."
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-3",
    "href": "courses/4302.2.html#ejemplo-3",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    while(contador &lt; 10) {;}\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg√≥ a 10\");\n    return 0;\n}\n\nMala implementaci√≥n ü§¢"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-4",
    "href": "courses/4302.2.html#ejemplo-4",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    while(contador &lt; 10) {;}\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg√≥ a 10\");\n    return 0;\n}\nBusy waiting"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-5",
    "href": "courses/4302.2.html#ejemplo-5",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    while(contador &lt; 10) {;}\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg√≥ a 10\");\n    return 0;\n}\nHambruna\n\n\nToma el mutex y no lo libera antes de esperar\nNo es Deadlock porque el primer proceso est√° despierto"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-6",
    "href": "courses/4302.2.html#ejemplo-6",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    if(contador == 10){\n        pthread_cond_broadcast(&cond);\n    }\n    while(contador &lt; 10){\n        pthread_cond_wait(&cond, &mutex);\n    }\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg√≥ a 10\");\n    return 0; \n}"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-7",
    "href": "courses/4302.2.html#ejemplo-7",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    if(contador == 10){\n        pthread_cond_broadcast(&cond);\n    }\n    while(contador &lt; 10){\n        pthread_cond_wait(&cond, &mutex);\n    }\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg√≥ a 10\");\n    return 0; \n}\nCondiciones a√±adidas"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-8",
    "href": "courses/4302.2.html#ejemplo-8",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    if(contador == 10){\n        pthread_cond_broadcast(&cond);\n    }\n    while(contador &lt; 10){\n        pthread_cond_wait(&cond, &mutex);\n    }\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg√≥ a 10\");\n    return 0; \n}\nEspera eficiente"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-9",
    "href": "courses/4302.2.html#ejemplo-9",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    if(contador == 10){\n        pthread_cond_broadcast(&cond);\n    }\n    while(contador &lt; 10){\n        pthread_cond_wait(&cond, &mutex);\n    }\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg√≥ a 10\");\n    return 0; \n}\nZona cr√≠tica respetada"
  },
  {
    "objectID": "courses/4302.2.html#ejemplo-10",
    "href": "courses/4302.2.html#ejemplo-10",
    "title": "Auxiliar 2",
    "section": "Ejemplo",
    "text": "Ejemplo\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nint contador = 0;\nint aumentar_contador_y_esperar_10(){\n    pthread_mutex_lock(&mutex);\n    contador++;\n    if(contador == 10){\n        pthread_cond_broadcast(&cond);\n    }\n    while(contador &lt; 10){\n        pthread_cond_wait(&cond, &mutex);\n    }\n    pthread_mutex_unlock(&mutex);\n    printf(\"Contador lleg√≥ a 10\");\n    return 0; \n}\nBuena implementaci√≥n ü§†"
  },
  {
    "objectID": "courses/4302.2.html#p2-colecta",
    "href": "courses/4302.2.html#p2-colecta",
    "title": "Auxiliar 2",
    "section": "P2 ‚Äî Colecta",
    "text": "P2 ‚Äî Colecta\nSe necesita crear un sistemas para juntar exactamente una cantidad \\(X\\) de dinero:\n\n\nDefinir el tipo de datos Colecta.\nProgramar la funci√≥n\nColecta *nuevaColecta(double meta);\nQue crea y retorna una colecta para juntar meta pesos.\nProgramar la funci√≥n\ndouble aportar(Colecta *c, double monto);\nQue es invocada desde m√∫ltiples procesos para contribuir monto pesos. El valor de retorno de la funci√≥n es el m√≠nimo entre monto y lo que falta para llegar a la meta.\nLa funci√≥n retornar una vez que la meta se cumpla"
  },
  {
    "objectID": "courses/index.html",
    "href": "courses/index.html",
    "title": "Cursos",
    "section": "",
    "text": "Aqu√≠ esta el material de cursos que he dictado",
    "crumbs": [
      "Cursos",
      "2024"
    ]
  },
  {
    "objectID": "courses/3501.1.html#su-auxiliar",
    "href": "courses/3501.1.html#su-auxiliar",
    "title": "Auxiliar 1",
    "section": "Su auxiliar",
    "text": "Su auxiliar\n\n\n\n\nVicente Gonz√°lez\nAuxiliar de\n\nPSS\nComputaci√≥n en GPU\nSistemas Operativos\nMetodolog√≠as de Dise√±o y Programaci√≥n\n\nSiempre disponible en persona üòÉ\nLento para responder correos üòü\nDoble titulaci√≥n\nNo duden en preguntar"
  },
  {
    "objectID": "courses/3501.1.html#terminal",
    "href": "courses/3501.1.html#terminal",
    "title": "Auxiliar 1",
    "section": "Terminal",
    "text": "Terminal\nAlgunas cosas para manejarse mejor\n\n\n\n\n\n\n\nComando\nDescripci√≥n\n\n\n\n\ncd &lt;ruta&gt;\n¬†Cambia al directorio &lt;ruta&gt;\n\n\nls/dir\n¬†Lista los archivos y directorios en el directorio actual\n\n\nmdkir &lt;nombre&gt;\n¬†Crea un directorio nuevo llamado &lt;nombre&gt;\n\n\nmv &lt;desde&gt; &lt;hacia&gt;\n¬†Mueve un archivo/directorio &lt;desde&gt; a una ruta &lt;hacia&gt;\n\n\nrm &lt;nombre&gt;1\n¬†Elimina/borra el archivo &lt;nombre&gt;\n\n\n\n\n\nPueden abusar del Tab para que les autocomplete y agregar --help para que les explique\nPueden agregar la flag -rf para borrar carpetas enteras"
  },
  {
    "objectID": "courses/3501.1.html#python",
    "href": "courses/3501.1.html#python",
    "title": "Auxiliar 1",
    "section": "Python",
    "text": "Python"
  },
  {
    "objectID": "courses/3501.1.html#pip",
    "href": "courses/3501.1.html#pip",
    "title": "Auxiliar 1",
    "section": "PIP",
    "text": "PIP\n\n\nGestor de paquetes de Python\nViene instalado con su versi√≥n de Python\nPaquetes como venv permiten gestionar ambientes\n\n\n\n\nDetalles de la instalaci√≥n aqui"
  },
  {
    "objectID": "courses/3501.1.html#pip-1",
    "href": "courses/3501.1.html#pip-1",
    "title": "Auxiliar 1",
    "section": "PIP",
    "text": "PIP\n\n\nPara crear ambientes (se crea en la carpeta .venv)\npython -m venv venv\nPara activarlo\nsource ./venv/bin/activate\nInstalar paquetes\npip install &lt;paquete&gt;\npip install -r &lt;archivo&gt;\n\n\n\n\nDetalles de la instalaci√≥n aqui"
  },
  {
    "objectID": "courses/3501.1.html#conda",
    "href": "courses/3501.1.html#conda",
    "title": "Auxiliar 1",
    "section": "Conda",
    "text": "Conda\n\n\nAlternativa a PIP\nGestor de paquetes del sistemas\nIncorpora ambientes\nRecomiendo Miniconda\n\n\n\n\nDudas con la instalaci√≥n por correo"
  },
  {
    "objectID": "courses/3501.1.html#conda-1",
    "href": "courses/3501.1.html#conda-1",
    "title": "Auxiliar 1",
    "section": "Conda",
    "text": "Conda\n\n\nPara crear ambientes\nconda env create -n &lt;nombre&gt; \nPara activarlo\nconda activate &lt;nombre&gt;\nInstalar paquetes\nconda install &lt;paquete&gt;\n\n\n\n\nDudas con la instalaci√≥n por correo"
  },
  {
    "objectID": "courses/3501.1.html#editor",
    "href": "courses/3501.1.html#editor",
    "title": "Auxiliar 1",
    "section": "Editor",
    "text": "Editor"
  },
  {
    "objectID": "courses/3501.1.html#vscode",
    "href": "courses/3501.1.html#vscode",
    "title": "Auxiliar 1",
    "section": "VSCode",
    "text": "VSCode\n\n\nSencillo y liviano\nUsa extensiones\nMicrosoft ü§¢\nGratis ü§ë\n\n\n\nDescargar"
  },
  {
    "objectID": "courses/3501.1.html#pycharm",
    "href": "courses/3501.1.html#pycharm",
    "title": "Auxiliar 1",
    "section": "PyCharm",
    "text": "PyCharm\n\n\nCompleto\nUsa plugins\nJetBrains ü§¢\nGratis (Community) y de Pago1 (Professional)\n\n\n\nDescargar\n\nSe puede obtener gratis con una licencia educacional"
  },
  {
    "objectID": "courses/3501.1.html#vim",
    "href": "courses/3501.1.html#vim",
    "title": "Auxiliar 1",
    "section": "Vim",
    "text": "Vim\n\n\nUltra liviano pero ultra extensible\nOpen Source\nLo usa el admin (yo üòé)\nMuy dif√≠cil, no recomendado\n\n\n\nDescargar"
  },
  {
    "objectID": "courses/3501.1.html#git",
    "href": "courses/3501.1.html#git",
    "title": "Auxiliar 1",
    "section": "Git",
    "text": "Git\n\n\n\n\nPara clonar repositorios\ngit clone &lt;url&gt; &lt;nombre_carpeta&gt;\nNO es necesario para el curso\nTutorial\n\n\n\n\n\n\n\n\n\n\n\nDetalles de la instalaci√≥n aqui"
  },
  {
    "objectID": "courses/3501.1.html#hello-world",
    "href": "courses/3501.1.html#hello-world",
    "title": "Auxiliar 1",
    "section": "Hello world!",
    "text": "Hello world!\n\n\n\n\n\n\n¬øCambiemos el color?"
  }
]